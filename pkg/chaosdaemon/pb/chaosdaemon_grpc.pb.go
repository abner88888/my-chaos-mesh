// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package chaosdaemon

import (
	context "context"
	empty "github.com/golang/protobuf/ptypes/empty"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// ChaosDaemonClient is the client API for ChaosDaemon service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ChaosDaemonClient interface {
	SetNetem(ctx context.Context, in *NetemRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	DeleteNetem(ctx context.Context, in *NetemRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	SetTbf(ctx context.Context, in *TbfRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	DeleteTbf(ctx context.Context, in *TbfRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	AddQdisc(ctx context.Context, in *QdiscRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	DelQdisc(ctx context.Context, in *QdiscRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	AddEmatchFilter(ctx context.Context, in *EmatchFilterRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	// generic tc filter del command
	DelTcFilter(ctx context.Context, in *TcFilterRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	FlushIpSet(ctx context.Context, in *IpSetRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	FlushIptables(ctx context.Context, in *IpTablesRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	SetTimeOffset(ctx context.Context, in *TimeRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	RecoverTimeOffset(ctx context.Context, in *TimeRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	ContainerKill(ctx context.Context, in *ContainerRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	ContainerGetPid(ctx context.Context, in *ContainerRequest, opts ...grpc.CallOption) (*ContainerResponse, error)
	ExecStressors(ctx context.Context, in *ExecStressRequest, opts ...grpc.CallOption) (*ExecStressResponse, error)
	CancelStressors(ctx context.Context, in *CancelStressRequest, opts ...grpc.CallOption) (*empty.Empty, error)
}

type chaosDaemonClient struct {
	cc grpc.ClientConnInterface
}

func NewChaosDaemonClient(cc grpc.ClientConnInterface) ChaosDaemonClient {
	return &chaosDaemonClient{cc}
}

func (c *chaosDaemonClient) SetNetem(ctx context.Context, in *NetemRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/chaosdaemon.ChaosDaemon/SetNetem", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chaosDaemonClient) DeleteNetem(ctx context.Context, in *NetemRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/chaosdaemon.ChaosDaemon/DeleteNetem", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chaosDaemonClient) SetTbf(ctx context.Context, in *TbfRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/chaosdaemon.ChaosDaemon/SetTbf", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chaosDaemonClient) DeleteTbf(ctx context.Context, in *TbfRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/chaosdaemon.ChaosDaemon/DeleteTbf", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chaosDaemonClient) AddQdisc(ctx context.Context, in *QdiscRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/chaosdaemon.ChaosDaemon/AddQdisc", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chaosDaemonClient) DelQdisc(ctx context.Context, in *QdiscRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/chaosdaemon.ChaosDaemon/DelQdisc", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chaosDaemonClient) AddEmatchFilter(ctx context.Context, in *EmatchFilterRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/chaosdaemon.ChaosDaemon/AddEmatchFilter", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chaosDaemonClient) DelTcFilter(ctx context.Context, in *TcFilterRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/chaosdaemon.ChaosDaemon/DelTcFilter", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chaosDaemonClient) FlushIpSet(ctx context.Context, in *IpSetRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/chaosdaemon.ChaosDaemon/FlushIpSet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chaosDaemonClient) FlushIptables(ctx context.Context, in *IpTablesRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/chaosdaemon.ChaosDaemon/FlushIptables", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chaosDaemonClient) SetTimeOffset(ctx context.Context, in *TimeRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/chaosdaemon.ChaosDaemon/SetTimeOffset", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chaosDaemonClient) RecoverTimeOffset(ctx context.Context, in *TimeRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/chaosdaemon.ChaosDaemon/RecoverTimeOffset", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chaosDaemonClient) ContainerKill(ctx context.Context, in *ContainerRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/chaosdaemon.ChaosDaemon/ContainerKill", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chaosDaemonClient) ContainerGetPid(ctx context.Context, in *ContainerRequest, opts ...grpc.CallOption) (*ContainerResponse, error) {
	out := new(ContainerResponse)
	err := c.cc.Invoke(ctx, "/chaosdaemon.ChaosDaemon/ContainerGetPid", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chaosDaemonClient) ExecStressors(ctx context.Context, in *ExecStressRequest, opts ...grpc.CallOption) (*ExecStressResponse, error) {
	out := new(ExecStressResponse)
	err := c.cc.Invoke(ctx, "/chaosdaemon.ChaosDaemon/ExecStressors", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chaosDaemonClient) CancelStressors(ctx context.Context, in *CancelStressRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/chaosdaemon.ChaosDaemon/CancelStressors", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ChaosDaemonServer is the server API for ChaosDaemon service.
// All implementations must embed UnimplementedChaosDaemonServer
// for forward compatibility
type ChaosDaemonServer interface {
	SetNetem(context.Context, *NetemRequest) (*empty.Empty, error)
	DeleteNetem(context.Context, *NetemRequest) (*empty.Empty, error)
	SetTbf(context.Context, *TbfRequest) (*empty.Empty, error)
	DeleteTbf(context.Context, *TbfRequest) (*empty.Empty, error)
	AddQdisc(context.Context, *QdiscRequest) (*empty.Empty, error)
	DelQdisc(context.Context, *QdiscRequest) (*empty.Empty, error)
	AddEmatchFilter(context.Context, *EmatchFilterRequest) (*empty.Empty, error)
	// generic tc filter del command
	DelTcFilter(context.Context, *TcFilterRequest) (*empty.Empty, error)
	FlushIpSet(context.Context, *IpSetRequest) (*empty.Empty, error)
	FlushIptables(context.Context, *IpTablesRequest) (*empty.Empty, error)
	SetTimeOffset(context.Context, *TimeRequest) (*empty.Empty, error)
	RecoverTimeOffset(context.Context, *TimeRequest) (*empty.Empty, error)
	ContainerKill(context.Context, *ContainerRequest) (*empty.Empty, error)
	ContainerGetPid(context.Context, *ContainerRequest) (*ContainerResponse, error)
	ExecStressors(context.Context, *ExecStressRequest) (*ExecStressResponse, error)
	CancelStressors(context.Context, *CancelStressRequest) (*empty.Empty, error)
	mustEmbedUnimplementedChaosDaemonServer()
}

// UnimplementedChaosDaemonServer must be embedded to have forward compatible implementations.
type UnimplementedChaosDaemonServer struct {
}

func (*UnimplementedChaosDaemonServer) SetNetem(context.Context, *NetemRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetNetem not implemented")
}
func (*UnimplementedChaosDaemonServer) DeleteNetem(context.Context, *NetemRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteNetem not implemented")
}
func (*UnimplementedChaosDaemonServer) SetTbf(context.Context, *TbfRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetTbf not implemented")
}
func (*UnimplementedChaosDaemonServer) DeleteTbf(context.Context, *TbfRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTbf not implemented")
}
func (*UnimplementedChaosDaemonServer) AddQdisc(context.Context, *QdiscRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddQdisc not implemented")
}
func (*UnimplementedChaosDaemonServer) DelQdisc(context.Context, *QdiscRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DelQdisc not implemented")
}
func (*UnimplementedChaosDaemonServer) AddEmatchFilter(context.Context, *EmatchFilterRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddEmatchFilter not implemented")
}
func (*UnimplementedChaosDaemonServer) DelTcFilter(context.Context, *TcFilterRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DelTcFilter not implemented")
}
func (*UnimplementedChaosDaemonServer) FlushIpSet(context.Context, *IpSetRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FlushIpSet not implemented")
}
func (*UnimplementedChaosDaemonServer) FlushIptables(context.Context, *IpTablesRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FlushIptables not implemented")
}
func (*UnimplementedChaosDaemonServer) SetTimeOffset(context.Context, *TimeRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetTimeOffset not implemented")
}
func (*UnimplementedChaosDaemonServer) RecoverTimeOffset(context.Context, *TimeRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RecoverTimeOffset not implemented")
}
func (*UnimplementedChaosDaemonServer) ContainerKill(context.Context, *ContainerRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ContainerKill not implemented")
}
func (*UnimplementedChaosDaemonServer) ContainerGetPid(context.Context, *ContainerRequest) (*ContainerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ContainerGetPid not implemented")
}
func (*UnimplementedChaosDaemonServer) ExecStressors(context.Context, *ExecStressRequest) (*ExecStressResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExecStressors not implemented")
}
func (*UnimplementedChaosDaemonServer) CancelStressors(context.Context, *CancelStressRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelStressors not implemented")
}
func (*UnimplementedChaosDaemonServer) mustEmbedUnimplementedChaosDaemonServer() {}

func RegisterChaosDaemonServer(s *grpc.Server, srv ChaosDaemonServer) {
	s.RegisterService(&_ChaosDaemon_serviceDesc, srv)
}

func _ChaosDaemon_SetNetem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NetemRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChaosDaemonServer).SetNetem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chaosdaemon.ChaosDaemon/SetNetem",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChaosDaemonServer).SetNetem(ctx, req.(*NetemRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChaosDaemon_DeleteNetem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NetemRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChaosDaemonServer).DeleteNetem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chaosdaemon.ChaosDaemon/DeleteNetem",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChaosDaemonServer).DeleteNetem(ctx, req.(*NetemRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChaosDaemon_SetTbf_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TbfRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChaosDaemonServer).SetTbf(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chaosdaemon.ChaosDaemon/SetTbf",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChaosDaemonServer).SetTbf(ctx, req.(*TbfRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChaosDaemon_DeleteTbf_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TbfRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChaosDaemonServer).DeleteTbf(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chaosdaemon.ChaosDaemon/DeleteTbf",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChaosDaemonServer).DeleteTbf(ctx, req.(*TbfRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChaosDaemon_AddQdisc_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QdiscRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChaosDaemonServer).AddQdisc(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chaosdaemon.ChaosDaemon/AddQdisc",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChaosDaemonServer).AddQdisc(ctx, req.(*QdiscRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChaosDaemon_DelQdisc_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QdiscRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChaosDaemonServer).DelQdisc(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chaosdaemon.ChaosDaemon/DelQdisc",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChaosDaemonServer).DelQdisc(ctx, req.(*QdiscRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChaosDaemon_AddEmatchFilter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmatchFilterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChaosDaemonServer).AddEmatchFilter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chaosdaemon.ChaosDaemon/AddEmatchFilter",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChaosDaemonServer).AddEmatchFilter(ctx, req.(*EmatchFilterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChaosDaemon_DelTcFilter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TcFilterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChaosDaemonServer).DelTcFilter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chaosdaemon.ChaosDaemon/DelTcFilter",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChaosDaemonServer).DelTcFilter(ctx, req.(*TcFilterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChaosDaemon_FlushIpSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IpSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChaosDaemonServer).FlushIpSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chaosdaemon.ChaosDaemon/FlushIpSet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChaosDaemonServer).FlushIpSet(ctx, req.(*IpSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChaosDaemon_FlushIptables_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IpTablesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChaosDaemonServer).FlushIptables(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chaosdaemon.ChaosDaemon/FlushIptables",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChaosDaemonServer).FlushIptables(ctx, req.(*IpTablesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChaosDaemon_SetTimeOffset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TimeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChaosDaemonServer).SetTimeOffset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chaosdaemon.ChaosDaemon/SetTimeOffset",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChaosDaemonServer).SetTimeOffset(ctx, req.(*TimeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChaosDaemon_RecoverTimeOffset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TimeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChaosDaemonServer).RecoverTimeOffset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chaosdaemon.ChaosDaemon/RecoverTimeOffset",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChaosDaemonServer).RecoverTimeOffset(ctx, req.(*TimeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChaosDaemon_ContainerKill_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContainerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChaosDaemonServer).ContainerKill(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chaosdaemon.ChaosDaemon/ContainerKill",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChaosDaemonServer).ContainerKill(ctx, req.(*ContainerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChaosDaemon_ContainerGetPid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContainerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChaosDaemonServer).ContainerGetPid(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chaosdaemon.ChaosDaemon/ContainerGetPid",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChaosDaemonServer).ContainerGetPid(ctx, req.(*ContainerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChaosDaemon_ExecStressors_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecStressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChaosDaemonServer).ExecStressors(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chaosdaemon.ChaosDaemon/ExecStressors",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChaosDaemonServer).ExecStressors(ctx, req.(*ExecStressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChaosDaemon_CancelStressors_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelStressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChaosDaemonServer).CancelStressors(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chaosdaemon.ChaosDaemon/CancelStressors",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChaosDaemonServer).CancelStressors(ctx, req.(*CancelStressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ChaosDaemon_serviceDesc = grpc.ServiceDesc{
	ServiceName: "chaosdaemon.ChaosDaemon",
	HandlerType: (*ChaosDaemonServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SetNetem",
			Handler:    _ChaosDaemon_SetNetem_Handler,
		},
		{
			MethodName: "DeleteNetem",
			Handler:    _ChaosDaemon_DeleteNetem_Handler,
		},
		{
			MethodName: "SetTbf",
			Handler:    _ChaosDaemon_SetTbf_Handler,
		},
		{
			MethodName: "DeleteTbf",
			Handler:    _ChaosDaemon_DeleteTbf_Handler,
		},
		{
			MethodName: "AddQdisc",
			Handler:    _ChaosDaemon_AddQdisc_Handler,
		},
		{
			MethodName: "DelQdisc",
			Handler:    _ChaosDaemon_DelQdisc_Handler,
		},
		{
			MethodName: "AddEmatchFilter",
			Handler:    _ChaosDaemon_AddEmatchFilter_Handler,
		},
		{
			MethodName: "DelTcFilter",
			Handler:    _ChaosDaemon_DelTcFilter_Handler,
		},
		{
			MethodName: "FlushIpSet",
			Handler:    _ChaosDaemon_FlushIpSet_Handler,
		},
		{
			MethodName: "FlushIptables",
			Handler:    _ChaosDaemon_FlushIptables_Handler,
		},
		{
			MethodName: "SetTimeOffset",
			Handler:    _ChaosDaemon_SetTimeOffset_Handler,
		},
		{
			MethodName: "RecoverTimeOffset",
			Handler:    _ChaosDaemon_RecoverTimeOffset_Handler,
		},
		{
			MethodName: "ContainerKill",
			Handler:    _ChaosDaemon_ContainerKill_Handler,
		},
		{
			MethodName: "ContainerGetPid",
			Handler:    _ChaosDaemon_ContainerGetPid_Handler,
		},
		{
			MethodName: "ExecStressors",
			Handler:    _ChaosDaemon_ExecStressors_Handler,
		},
		{
			MethodName: "CancelStressors",
			Handler:    _ChaosDaemon_CancelStressors_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "chaosdaemon.proto",
}
