/**
 * Generated by orval v6.12.1 🍺
 * Do not edit manually.
 * Chaos Mesh Dashboard API
 * Swagger for Chaos Mesh Dashboard. If you encounter any problems with API, please click on the issues link below to report.
 * OpenAPI spec version: 2.2
 */
import { faker } from '@faker-js/faker'
import { rest } from 'msw'

export const getDeleteArchivesMock = () => ({ status: faker.random.word() })

export const getGetArchivesMock = () =>
  Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
    created_at: faker.random.word(),
    kind: faker.random.word(),
    name: faker.random.word(),
    namespace: faker.random.word(),
    uid: faker.random.word(),
  }))

export const getDeleteArchivesUidMock = () => ({ status: faker.random.word() })

export const getGetArchivesUidMock = () => ({
  created_at: faker.random.word(),
  kind: faker.random.word(),
  kube_object: {
    apiVersion: faker.random.word(),
    kind: faker.random.word(),
    metadata: {
      annotations: {
        clfo3x4980000q0dibv2t6itf: faker.random.word(),
      },
      labels: {
        clfo3x4980001q0di29jc61gl: faker.random.word(),
      },
      name: faker.random.word(),
      namespace: faker.random.word(),
    },
    spec: {},
  },
  name: faker.random.word(),
  namespace: faker.random.word(),
  uid: faker.random.word(),
})

export const getDeleteArchivesSchedulesMock = () => ({ status: faker.random.word() })

export const getGetArchivesSchedulesMock = () =>
  Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
    created_at: faker.random.word(),
    kind: faker.random.word(),
    name: faker.random.word(),
    namespace: faker.random.word(),
    uid: faker.random.word(),
  }))

export const getDeleteArchivesSchedulesUidMock = () => ({ status: faker.random.word() })

export const getGetArchivesSchedulesUidMock = () => ({
  created_at: faker.random.word(),
  kind: faker.random.word(),
  kube_object: {
    apiVersion: faker.random.word(),
    kind: faker.random.word(),
    metadata: {
      annotations: {
        clfo3x49e0002q0di1fao6k1n: faker.random.word(),
      },
      labels: {
        clfo3x49e0003q0di9vfv7r6f: faker.random.word(),
      },
      name: faker.random.word(),
      namespace: faker.random.word(),
    },
    spec: {},
  },
  name: faker.random.word(),
  namespace: faker.random.word(),
  uid: faker.random.word(),
})

export const getDeleteArchivesWorkflowsMock = () => ({ status: faker.random.word() })

export const getGetArchivesWorkflowsMock = () =>
  Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
    created_at: faker.random.word(),
    kind: faker.random.word(),
    name: faker.random.word(),
    namespace: faker.random.word(),
    uid: faker.random.word(),
  }))

export const getDeleteArchivesWorkflowsUidMock = () => ({ status: faker.random.word() })

export const getGetArchivesWorkflowsUidMock = () => ({
  created_at: faker.random.word(),
  kind: faker.random.word(),
  kube_object: {
    apiVersion: faker.random.word(),
    kind: faker.random.word(),
    metadata: {
      annotations: {
        clfo3x49i0004q0difqg44hue: faker.random.word(),
      },
      labels: {
        clfo3x49j0005q0didfiq39xy: faker.random.word(),
      },
      name: faker.random.word(),
      namespace: faker.random.word(),
    },
    spec: {},
  },
  name: faker.random.word(),
  namespace: faker.random.word(),
  uid: faker.random.word(),
})

export const getGetCommonAnnotationsMock = () => ({
  clfo3x49k0006q0dih5xha12p: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
    () => faker.random.word()
  ),
})

export const getGetCommonChaosAvailableNamespacesMock = () =>
  Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, () => faker.random.word())

export const getGetCommonConfigMock = () => ({
  burst: faker.datatype.number({ min: undefined, max: undefined }),
  cluster_mode: faker.datatype.boolean(),
  dns_server_create: faker.datatype.boolean(),
  enableFilterNamespace: faker.datatype.boolean(),
  enableProfiling: faker.datatype.boolean(),
  gcp_security_mode: faker.datatype.boolean(),
  listen_host: faker.random.word(),
  listen_port: faker.datatype.number({ min: undefined, max: undefined }),
  qps: faker.datatype.number({ min: undefined, max: undefined }),
  root_path: faker.random.word(),
  security_mode: faker.datatype.boolean(),
  target_namespace: faker.random.word(),
  version: faker.random.word(),
})

export const getGetCommonKindsMock = () =>
  Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, () => faker.random.word())

export const getGetCommonLabelsMock = () => ({
  clfo3x49o0007q0di0og48pxw: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
    () => faker.random.word()
  ),
})

export const getGetCommonNamespacesMock = () =>
  Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, () => faker.random.word())

export const getGetCommonPhysicalmachineAnnotationsMock = () => ({
  clfo3x49p0008q0di6cm5b4lc: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
    () => faker.random.word()
  ),
})

export const getGetCommonPhysicalmachineLabelsMock = () => ({
  clfo3x49q0009q0di9djv0w0z: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
    () => faker.random.word()
  ),
})

export const getPostCommonPhysicalmachinesMock = () =>
  Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
    address: faker.random.word(),
    name: faker.random.word(),
    namespace: faker.random.word(),
  }))

export const getPostCommonPodsMock = () =>
  Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
    ip: faker.random.word(),
    name: faker.random.word(),
    namespace: faker.random.word(),
    state: faker.random.word(),
  }))

export const getGetCommonRbacConfigMock = () => ({
  clfo3x49t000aq0dieoo04vb0: faker.random.word(),
})

export const getGetEventsMock = () =>
  Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
    created_at: faker.random.word(),
    id: faker.datatype.number({ min: undefined, max: undefined }),
    kind: faker.random.word(),
    message: faker.random.word(),
    name: faker.random.word(),
    namespace: faker.random.word(),
    object_id: faker.random.word(),
    reason: faker.random.word(),
    type: faker.random.word(),
  }))

export const getGetEventsIdMock = () => ({
  created_at: faker.random.word(),
  id: faker.datatype.number({ min: undefined, max: undefined }),
  kind: faker.random.word(),
  message: faker.random.word(),
  name: faker.random.word(),
  namespace: faker.random.word(),
  object_id: faker.random.word(),
  reason: faker.random.word(),
  type: faker.random.word(),
})

export const getGetEventsWorkflowUidMock = () =>
  Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
    created_at: faker.random.word(),
    id: faker.datatype.number({ min: undefined, max: undefined }),
    kind: faker.random.word(),
    message: faker.random.word(),
    name: faker.random.word(),
    namespace: faker.random.word(),
    object_id: faker.random.word(),
    reason: faker.random.word(),
    type: faker.random.word(),
  }))

export const getDeleteExperimentsMock = () => ({ status: faker.random.word() })

export const getGetExperimentsMock = () =>
  Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
    created_at: faker.random.word(),
    failed_message: faker.random.word(),
    kind: faker.random.word(),
    name: faker.random.word(),
    namespace: faker.random.word(),
    status: faker.random.word(),
    uid: faker.random.word(),
  }))

export const getPostExperimentsMock = () => ({})

export const getDeleteExperimentsUidMock = () => ({ status: faker.random.word() })

export const getGetExperimentsUidMock = () => ({
  created_at: faker.random.word(),
  failed_message: faker.random.word(),
  kind: faker.random.word(),
  kube_object: {
    apiVersion: faker.random.word(),
    kind: faker.random.word(),
    metadata: {
      annotations: {
        clfo3x49z000bq0difzkiggro: faker.random.word(),
      },
      labels: {
        clfo3x49z000cq0di5hzna2lr: faker.random.word(),
      },
      name: faker.random.word(),
      namespace: faker.random.word(),
    },
    spec: {},
  },
  name: faker.random.word(),
  namespace: faker.random.word(),
  status: faker.random.word(),
  uid: faker.random.word(),
})

export const getPutExperimentsPauseUidMock = () => ({ status: faker.random.word() })

export const getPutExperimentsStartUidMock = () => ({ status: faker.random.word() })

export const getGetExperimentsStateMock = () => ({
  deleting: faker.datatype.number({ min: undefined, max: undefined }),
  finished: faker.datatype.number({ min: undefined, max: undefined }),
  injecting: faker.datatype.number({ min: undefined, max: undefined }),
  paused: faker.datatype.number({ min: undefined, max: undefined }),
  running: faker.datatype.number({ min: undefined, max: undefined }),
})

export const getDeleteSchedulesMock = () => ({ status: faker.random.word() })

export const getGetSchedulesMock = () =>
  Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
    created_at: faker.random.word(),
    kind: faker.random.word(),
    name: faker.random.word(),
    namespace: faker.random.word(),
    status: faker.random.word(),
    uid: faker.random.word(),
  }))

export const getPostSchedulesMock = () => ({
  annotations: {
    clfo3x4a2000dq0di5bwdhguq: faker.random.word(),
  },
  apiVersion: faker.random.word(),
  creationTimestamp: faker.random.word(),
  deletionGracePeriodSeconds: faker.datatype.number({ min: undefined, max: undefined }),
  deletionTimestamp: faker.random.word(),
  finalizers: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
    faker.random.word()
  ),
  generateName: faker.random.word(),
  generation: faker.datatype.number({ min: undefined, max: undefined }),
  kind: faker.random.word(),
  labels: {
    clfo3x4a2000eq0dib3f63krt: faker.random.word(),
  },
  managedFields: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
    apiVersion: faker.random.word(),
    fieldsType: faker.random.word(),
    fieldsV1: {},
    manager: faker.random.word(),
    operation: faker.random.word(),
    subresource: faker.random.word(),
    time: faker.random.word(),
  })),
  name: faker.random.word(),
  namespace: faker.random.word(),
  ownerReferences: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
    apiVersion: faker.random.word(),
    blockOwnerDeletion: faker.datatype.boolean(),
    controller: faker.datatype.boolean(),
    kind: faker.random.word(),
    name: faker.random.word(),
    uid: faker.random.word(),
  })),
  resourceVersion: faker.random.word(),
  selfLink: faker.random.word(),
  spec: {
    awsChaos: {
      action: faker.random.word(),
      awsRegion: faker.random.word(),
      deviceName: faker.random.word(),
      duration: faker.random.word(),
      ec2Instance: faker.random.word(),
      endpoint: faker.random.word(),
      remoteCluster: faker.random.word(),
      secretName: faker.random.word(),
      volumeID: faker.random.word(),
    },
    azureChaos: {
      action: faker.random.word(),
      diskName: faker.random.word(),
      duration: faker.random.word(),
      lun: faker.datatype.number({ min: undefined, max: undefined }),
      remoteCluster: faker.random.word(),
      resourceGroupName: faker.random.word(),
      secretName: faker.random.word(),
      subscriptionID: faker.random.word(),
      vmName: faker.random.word(),
    },
    blockChaos: {
      action: faker.random.word(),
      containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      delay: { correlation: faker.random.word(), jitter: faker.random.word(), latency: faker.random.word() },
      duration: faker.random.word(),
      mode: faker.random.word(),
      remoteCluster: faker.random.word(),
      selector: {
        annotationSelectors: {
          clfo3x4a2000fq0di83ezctn3: faker.random.word(),
        },
        fieldSelectors: {
          clfo3x4a2000gq0di0769gqu9: faker.random.word(),
        },
        labelSelectors: {
          clfo3x4a2000hq0di62og4aja: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        nodeSelectors: {
          clfo3x4a2000iq0diadz07r07: faker.random.word(),
        },
        nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        pods: {
          clfo3x4a2000jq0dibtj15qd2: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1
          ).map(() => faker.random.word()),
        },
      },
      value: faker.random.word(),
      volumeName: faker.random.word(),
    },
    concurrencyPolicy: faker.random.word(),
    dnsChaos: {
      action: faker.random.word(),
      containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      duration: faker.random.word(),
      mode: faker.random.word(),
      patterns: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      remoteCluster: faker.random.word(),
      selector: {
        annotationSelectors: {
          clfo3x4a2000kq0di17puaxyd: faker.random.word(),
        },
        fieldSelectors: {
          clfo3x4a2000lq0diglc6c2t1: faker.random.word(),
        },
        labelSelectors: {
          clfo3x4a2000mq0diheupck4r: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        nodeSelectors: {
          clfo3x4a2000nq0diap344293: faker.random.word(),
        },
        nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        pods: {
          clfo3x4a2000oq0di5g2k71jg: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1
          ).map(() => faker.random.word()),
        },
      },
      value: faker.random.word(),
    },
    gcpChaos: {
      action: faker.random.word(),
      deviceNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      duration: faker.random.word(),
      instance: faker.random.word(),
      project: faker.random.word(),
      remoteCluster: faker.random.word(),
      secretName: faker.random.word(),
      zone: faker.random.word(),
    },
    historyLimit: faker.datatype.number({ min: undefined, max: undefined }),
    httpChaos: {
      abort: faker.datatype.boolean(),
      code: faker.datatype.number({ min: undefined, max: undefined }),
      delay: faker.random.word(),
      duration: faker.random.word(),
      method: faker.random.word(),
      mode: faker.random.word(),
      patch: {
        body: { type: faker.random.word(), value: faker.random.word() },
        headers: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word()
          )
        ),
        queries: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word()
          )
        ),
      },
      path: faker.random.word(),
      port: faker.datatype.number({ min: undefined, max: undefined }),
      remoteCluster: faker.random.word(),
      replace: {
        body: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.datatype.number({ min: undefined, max: undefined })
        ),
        code: faker.datatype.number({ min: undefined, max: undefined }),
        headers: {
          clfo3x4a2000pq0dias88feeh: faker.random.word(),
        },
        method: faker.random.word(),
        path: faker.random.word(),
        queries: {
          clfo3x4a3000qq0difzv97tu5: faker.random.word(),
        },
      },
      request_headers: {
        clfo3x4a3000rq0di2p12cco2: faker.random.word(),
      },
      response_headers: {
        clfo3x4a3000sq0di8rt4gihp: faker.random.word(),
      },
      selector: {
        annotationSelectors: {
          clfo3x4a3000tq0di8tiy1shs: faker.random.word(),
        },
        fieldSelectors: {
          clfo3x4a3000uq0di0upbe4y1: faker.random.word(),
        },
        labelSelectors: {
          clfo3x4a3000vq0dif1gtan1h: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        nodeSelectors: {
          clfo3x4a3000wq0dihgdoakbw: faker.random.word(),
        },
        nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        pods: {
          clfo3x4a3000xq0di4fe30blt: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1
          ).map(() => faker.random.word()),
        },
      },
      target: faker.random.word(),
      tls: {
        caName: faker.random.word(),
        certName: faker.random.word(),
        keyName: faker.random.word(),
        secretName: faker.random.word(),
        secretNamespace: faker.random.word(),
      },
      value: faker.random.word(),
    },
    ioChaos: {
      action: faker.random.word(),
      attr: {
        atime: {
          nsec: faker.datatype.number({ min: undefined, max: undefined }),
          sec: faker.datatype.number({ min: undefined, max: undefined }),
        },
        blocks: faker.datatype.number({ min: undefined, max: undefined }),
        ctime: {
          nsec: faker.datatype.number({ min: undefined, max: undefined }),
          sec: faker.datatype.number({ min: undefined, max: undefined }),
        },
        gid: faker.datatype.number({ min: undefined, max: undefined }),
        ino: faker.datatype.number({ min: undefined, max: undefined }),
        kind: faker.random.word(),
        mtime: {
          nsec: faker.datatype.number({ min: undefined, max: undefined }),
          sec: faker.datatype.number({ min: undefined, max: undefined }),
        },
        nlink: faker.datatype.number({ min: undefined, max: undefined }),
        perm: faker.datatype.number({ min: undefined, max: undefined }),
        rdev: faker.datatype.number({ min: undefined, max: undefined }),
        size: faker.datatype.number({ min: undefined, max: undefined }),
        uid: faker.datatype.number({ min: undefined, max: undefined }),
      },
      containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      delay: faker.random.word(),
      duration: faker.random.word(),
      errno: faker.datatype.number({ min: undefined, max: undefined }),
      methods: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      mistake: {
        filling: faker.random.word(),
        maxLength: faker.datatype.number({ min: undefined, max: undefined }),
        maxOccurrences: faker.datatype.number({ min: undefined, max: undefined }),
      },
      mode: faker.random.word(),
      path: faker.random.word(),
      percent: faker.datatype.number({ min: undefined, max: undefined }),
      remoteCluster: faker.random.word(),
      selector: {
        annotationSelectors: {
          clfo3x4a3000yq0di68m9egco: faker.random.word(),
        },
        fieldSelectors: {
          clfo3x4a3000zq0digsww259z: faker.random.word(),
        },
        labelSelectors: {
          clfo3x4a30010q0dif7zk46yy: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        nodeSelectors: {
          clfo3x4a30011q0di5j3p496u: faker.random.word(),
        },
        nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        pods: {
          clfo3x4a30012q0di243c3vgn: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1
          ).map(() => faker.random.word()),
        },
      },
      value: faker.random.word(),
      volumePath: faker.random.word(),
    },
    jvmChaos: {
      action: faker.random.word(),
      class: faker.random.word(),
      containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      cpuCount: faker.datatype.number({ min: undefined, max: undefined }),
      database: faker.random.word(),
      duration: faker.random.word(),
      exception: faker.random.word(),
      latency: faker.datatype.number({ min: undefined, max: undefined }),
      memType: faker.random.word(),
      method: faker.random.word(),
      mode: faker.random.word(),
      mysqlConnectorVersion: faker.random.word(),
      name: faker.random.word(),
      pid: faker.datatype.number({ min: undefined, max: undefined }),
      port: faker.datatype.number({ min: undefined, max: undefined }),
      remoteCluster: faker.random.word(),
      ruleData: faker.random.word(),
      selector: {
        annotationSelectors: {
          clfo3x4a30013q0di2r4se4vv: faker.random.word(),
        },
        fieldSelectors: {
          clfo3x4a30014q0difh5ha3q0: faker.random.word(),
        },
        labelSelectors: {
          clfo3x4a30015q0di9u5vft1j: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        nodeSelectors: {
          clfo3x4a30016q0difmj61xfv: faker.random.word(),
        },
        nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        pods: {
          clfo3x4a30017q0didof223qp: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1
          ).map(() => faker.random.word()),
        },
      },
      sqlType: faker.random.word(),
      table: faker.random.word(),
      value: faker.random.word(),
    },
    kernelChaos: {
      containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      duration: faker.random.word(),
      failKernRequest: {
        callchain: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
          funcname: faker.random.word(),
          parameters: faker.random.word(),
          predicate: faker.random.word(),
        })),
        failtype: faker.datatype.number({ min: undefined, max: undefined }),
        headers: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        probability: faker.datatype.number({ min: undefined, max: undefined }),
        times: faker.datatype.number({ min: undefined, max: undefined }),
      },
      mode: faker.random.word(),
      remoteCluster: faker.random.word(),
      selector: {
        annotationSelectors: {
          clfo3x4a30018q0difrgtgnxx: faker.random.word(),
        },
        fieldSelectors: {
          clfo3x4a30019q0di1mjsb1ze: faker.random.word(),
        },
        labelSelectors: {
          clfo3x4a3001aq0di7y5bdkm3: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        nodeSelectors: {
          clfo3x4a3001bq0di36tbahco: faker.random.word(),
        },
        nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        pods: {
          clfo3x4a3001cq0difx241g61: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1
          ).map(() => faker.random.word()),
        },
      },
      value: faker.random.word(),
    },
    networkChaos: {
      action: faker.random.word(),
      bandwidth: {
        buffer: faker.datatype.number({ min: undefined, max: undefined }),
        limit: faker.datatype.number({ min: undefined, max: undefined }),
        minburst: faker.datatype.number({ min: undefined, max: undefined }),
        peakrate: faker.datatype.number({ min: undefined, max: undefined }),
        rate: faker.random.word(),
      },
      corrupt: { correlation: faker.random.word(), corrupt: faker.random.word() },
      delay: {
        correlation: faker.random.word(),
        jitter: faker.random.word(),
        latency: faker.random.word(),
        reorder: {
          correlation: faker.random.word(),
          gap: faker.datatype.number({ min: undefined, max: undefined }),
          reorder: faker.random.word(),
        },
      },
      device: faker.random.word(),
      direction: faker.random.word(),
      duplicate: { correlation: faker.random.word(), duplicate: faker.random.word() },
      duration: faker.random.word(),
      externalTargets: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      loss: { correlation: faker.random.word(), loss: faker.random.word() },
      mode: faker.random.word(),
      remoteCluster: faker.random.word(),
      selector: {
        annotationSelectors: {
          clfo3x4a3001dq0difku0h3eh: faker.random.word(),
        },
        fieldSelectors: {
          clfo3x4a3001eq0di7nwuhtei: faker.random.word(),
        },
        labelSelectors: {
          clfo3x4a3001fq0diefco8zt6: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        nodeSelectors: {
          clfo3x4a3001gq0di2l4v0sm2: faker.random.word(),
        },
        nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        pods: {
          clfo3x4a3001hq0di5zdbgpe1: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1
          ).map(() => faker.random.word()),
        },
      },
      target: {
        mode: faker.random.word(),
        selector: {
          annotationSelectors: {
            clfo3x4a3001iq0dibesp2srn: faker.random.word(),
          },
          fieldSelectors: {
            clfo3x4a3001jq0di0dt5fi1l: faker.random.word(),
          },
          labelSelectors: {
            clfo3x4a3001kq0di3trqgp23: faker.random.word(),
          },
          namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word()
          ),
          nodeSelectors: {
            clfo3x4a3001lq0dia8i795lm: faker.random.word(),
          },
          nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word()
          ),
          podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
            () => faker.random.word()
          ),
          pods: {
            clfo3x4a3001mq0di5sbyg0oj: Array.from(
              { length: faker.datatype.number({ min: 1, max: 10 }) },
              (_, i) => i + 1
            ).map(() => faker.random.word()),
          },
        },
        value: faker.random.word(),
      },
      targetDevice: faker.random.word(),
      value: faker.random.word(),
    },
    physicalmachineChaos: {
      action: faker.random.word(),
      address: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      clock: {
        'clock-ids-slice': faker.random.word(),
        pid: faker.datatype.number({ min: undefined, max: undefined }),
        'time-offset': faker.random.word(),
      },
      'disk-fill': {
        'fill-by-fallocate': faker.datatype.boolean(),
        path: faker.random.word(),
        size: faker.random.word(),
      },
      'disk-read-payload': {
        path: faker.random.word(),
        'payload-process-num': faker.datatype.number({ min: undefined, max: undefined }),
        size: faker.random.word(),
      },
      'disk-write-payload': {
        path: faker.random.word(),
        'payload-process-num': faker.datatype.number({ min: undefined, max: undefined }),
        size: faker.random.word(),
      },
      duration: faker.random.word(),
      'file-append': {
        count: faker.datatype.number({ min: undefined, max: undefined }),
        data: faker.random.word(),
        'file-name': faker.random.word(),
      },
      'file-create': { 'dir-name': faker.random.word(), 'file-name': faker.random.word() },
      'file-delete': { 'dir-name': faker.random.word(), 'file-name': faker.random.word() },
      'file-modify': {
        'file-name': faker.random.word(),
        privilege: faker.datatype.number({ min: undefined, max: undefined }),
      },
      'file-rename': { 'dest-file': faker.random.word(), 'source-file': faker.random.word() },
      'file-replace': {
        'dest-string': faker.random.word(),
        'file-name': faker.random.word(),
        line: faker.datatype.number({ min: undefined, max: undefined }),
        'origin-string': faker.random.word(),
      },
      'http-abort': {
        code: faker.random.word(),
        method: faker.random.word(),
        path: faker.random.word(),
        port: faker.datatype.number({ min: undefined, max: undefined }),
        proxy_ports: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.datatype.number({ min: undefined, max: undefined })
        ),
        target: faker.random.word(),
      },
      'http-config': { file_path: faker.random.word() },
      'http-delay': {
        code: faker.random.word(),
        delay: faker.random.word(),
        method: faker.random.word(),
        path: faker.random.word(),
        port: faker.datatype.number({ min: undefined, max: undefined }),
        proxy_ports: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.datatype.number({ min: undefined, max: undefined })
        ),
        target: faker.random.word(),
      },
      'http-request': {
        count: faker.datatype.number({ min: undefined, max: undefined }),
        'enable-conn-pool': faker.datatype.boolean(),
        url: faker.random.word(),
      },
      'jvm-exception': {
        class: faker.random.word(),
        exception: faker.random.word(),
        method: faker.random.word(),
        pid: faker.datatype.number({ min: undefined, max: undefined }),
        port: faker.datatype.number({ min: undefined, max: undefined }),
      },
      'jvm-gc': {
        pid: faker.datatype.number({ min: undefined, max: undefined }),
        port: faker.datatype.number({ min: undefined, max: undefined }),
      },
      'jvm-latency': {
        class: faker.random.word(),
        latency: faker.datatype.number({ min: undefined, max: undefined }),
        method: faker.random.word(),
        pid: faker.datatype.number({ min: undefined, max: undefined }),
        port: faker.datatype.number({ min: undefined, max: undefined }),
      },
      'jvm-mysql': {
        database: faker.random.word(),
        exception: faker.random.word(),
        latency: faker.datatype.number({ min: undefined, max: undefined }),
        mysqlConnectorVersion: faker.random.word(),
        pid: faker.datatype.number({ min: undefined, max: undefined }),
        port: faker.datatype.number({ min: undefined, max: undefined }),
        sqlType: faker.random.word(),
        table: faker.random.word(),
      },
      'jvm-return': {
        class: faker.random.word(),
        method: faker.random.word(),
        pid: faker.datatype.number({ min: undefined, max: undefined }),
        port: faker.datatype.number({ min: undefined, max: undefined }),
        value: faker.random.word(),
      },
      'jvm-rule-data': {
        pid: faker.datatype.number({ min: undefined, max: undefined }),
        port: faker.datatype.number({ min: undefined, max: undefined }),
        'rule-data': faker.random.word(),
      },
      'jvm-stress': {
        'cpu-count': faker.datatype.number({ min: undefined, max: undefined }),
        'mem-type': faker.random.word(),
        pid: faker.datatype.number({ min: undefined, max: undefined }),
        port: faker.datatype.number({ min: undefined, max: undefined }),
      },
      'kafka-fill': {
        host: faker.random.word(),
        maxBytes: faker.datatype.number({ min: undefined, max: undefined }),
        messageSize: faker.datatype.number({ min: undefined, max: undefined }),
        password: faker.random.word(),
        port: faker.datatype.number({ min: undefined, max: undefined }),
        reloadCommand: faker.random.word(),
        topic: faker.random.word(),
        username: faker.random.word(),
      },
      'kafka-flood': {
        host: faker.random.word(),
        messageSize: faker.datatype.number({ min: undefined, max: undefined }),
        password: faker.random.word(),
        port: faker.datatype.number({ min: undefined, max: undefined }),
        threads: faker.datatype.number({ min: undefined, max: undefined }),
        topic: faker.random.word(),
        username: faker.random.word(),
      },
      'kafka-io': {
        configFile: faker.random.word(),
        nonReadable: faker.datatype.boolean(),
        nonWritable: faker.datatype.boolean(),
        topic: faker.random.word(),
      },
      mode: faker.random.word(),
      'network-bandwidth': {
        buffer: faker.datatype.number({ min: undefined, max: undefined }),
        device: faker.random.word(),
        hostname: faker.random.word(),
        'ip-address': faker.random.word(),
        limit: faker.datatype.number({ min: undefined, max: undefined }),
        minburst: faker.datatype.number({ min: undefined, max: undefined }),
        peakrate: faker.datatype.number({ min: undefined, max: undefined }),
        rate: faker.random.word(),
      },
      'network-corrupt': {
        correlation: faker.random.word(),
        device: faker.random.word(),
        'egress-port': faker.random.word(),
        hostname: faker.random.word(),
        'ip-address': faker.random.word(),
        'ip-protocol': faker.random.word(),
        percent: faker.random.word(),
        'source-port': faker.random.word(),
      },
      'network-delay': {
        'accept-tcp-flags': faker.random.word(),
        correlation: faker.random.word(),
        device: faker.random.word(),
        'egress-port': faker.random.word(),
        hostname: faker.random.word(),
        'ip-address': faker.random.word(),
        'ip-protocol': faker.random.word(),
        jitter: faker.random.word(),
        latency: faker.random.word(),
        'source-port': faker.random.word(),
      },
      'network-dns': {
        'dns-domain-name': faker.random.word(),
        'dns-ip': faker.random.word(),
        'dns-server': faker.random.word(),
      },
      'network-down': { device: faker.random.word(), duration: faker.random.word() },
      'network-duplicate': {
        correlation: faker.random.word(),
        device: faker.random.word(),
        'egress-port': faker.random.word(),
        hostname: faker.random.word(),
        'ip-address': faker.random.word(),
        'ip-protocol': faker.random.word(),
        percent: faker.random.word(),
        'source-port': faker.random.word(),
      },
      'network-flood': {
        duration: faker.random.word(),
        'ip-address': faker.random.word(),
        parallel: faker.datatype.number({ min: undefined, max: undefined }),
        port: faker.random.word(),
        rate: faker.random.word(),
      },
      'network-loss': {
        correlation: faker.random.word(),
        device: faker.random.word(),
        'egress-port': faker.random.word(),
        hostname: faker.random.word(),
        'ip-address': faker.random.word(),
        'ip-protocol': faker.random.word(),
        percent: faker.random.word(),
        'source-port': faker.random.word(),
      },
      'network-partition': {
        'accept-tcp-flags': faker.random.word(),
        device: faker.random.word(),
        direction: faker.random.word(),
        hostname: faker.random.word(),
        'ip-address': faker.random.word(),
        'ip-protocol': faker.random.word(),
      },
      process: {
        process: faker.random.word(),
        recoverCmd: faker.random.word(),
        signal: faker.datatype.number({ min: undefined, max: undefined }),
      },
      'redis-cacheLimit': {
        addr: faker.random.word(),
        cacheSize: faker.random.word(),
        password: faker.random.word(),
        percent: faker.random.word(),
      },
      'redis-expiration': {
        addr: faker.random.word(),
        expiration: faker.random.word(),
        key: faker.random.word(),
        option: faker.random.word(),
        password: faker.random.word(),
      },
      'redis-penetration': {
        addr: faker.random.word(),
        password: faker.random.word(),
        requestNum: faker.datatype.number({ min: undefined, max: undefined }),
      },
      'redis-restart': {
        addr: faker.random.word(),
        conf: faker.random.word(),
        flushConfig: faker.datatype.boolean(),
        password: faker.random.word(),
        redisPath: faker.datatype.boolean(),
      },
      'redis-stop': {
        addr: faker.random.word(),
        conf: faker.random.word(),
        flushConfig: faker.datatype.boolean(),
        password: faker.random.word(),
        redisPath: faker.datatype.boolean(),
      },
      remoteCluster: faker.random.word(),
      selector: {
        annotationSelectors: {
          clfo3x4a5001nq0di9xriboun: faker.random.word(),
        },
        fieldSelectors: {
          clfo3x4a5001oq0di404d7uhh: faker.random.word(),
        },
        labelSelectors: {
          clfo3x4a5001pq0di0d3e7fyx: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        physicalMachines: {
          clfo3x4a5001qq0di5ilp2t7q: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1
          ).map(() => faker.random.word()),
        },
      },
      'stress-cpu': {
        load: faker.datatype.number({ min: undefined, max: undefined }),
        options: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        workers: faker.datatype.number({ min: undefined, max: undefined }),
      },
      'stress-mem': {
        options: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        size: faker.random.word(),
      },
      user_defined: { attackCmd: faker.random.word(), recoverCmd: faker.random.word() },
      value: faker.random.word(),
      vm: { 'vm-name': faker.random.word() },
    },
    podChaos: {
      action: faker.random.word(),
      containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      duration: faker.random.word(),
      gracePeriod: faker.datatype.number({ min: undefined, max: undefined }),
      mode: faker.random.word(),
      remoteCluster: faker.random.word(),
      selector: {
        annotationSelectors: {
          clfo3x4a5001rq0did092dmsk: faker.random.word(),
        },
        fieldSelectors: {
          clfo3x4a5001sq0di4zsren6k: faker.random.word(),
        },
        labelSelectors: {
          clfo3x4a5001tq0dibj195lzb: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        nodeSelectors: {
          clfo3x4a5001uq0dibvjpbrz4: faker.random.word(),
        },
        nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        pods: {
          clfo3x4a5001vq0dic52igo2w: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1
          ).map(() => faker.random.word()),
        },
      },
      value: faker.random.word(),
    },
    schedule: faker.random.word(),
    startingDeadlineSeconds: faker.datatype.number({ min: undefined, max: undefined }),
    stressChaos: {
      containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      duration: faker.random.word(),
      mode: faker.random.word(),
      remoteCluster: faker.random.word(),
      selector: {
        annotationSelectors: {
          clfo3x4a5001wq0dicmgthwiq: faker.random.word(),
        },
        fieldSelectors: {
          clfo3x4a5001xq0di7ua201td: faker.random.word(),
        },
        labelSelectors: {
          clfo3x4a5001yq0di3p8a3avi: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        nodeSelectors: {
          clfo3x4a5001zq0di2m9q153b: faker.random.word(),
        },
        nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        pods: {
          clfo3x4a50020q0di62ag1eut: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1
          ).map(() => faker.random.word()),
        },
      },
      stressngStressors: faker.random.word(),
      stressors: {
        cpu: {
          load: faker.datatype.number({ min: undefined, max: undefined }),
          options: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word()
          ),
          workers: faker.datatype.number({ min: undefined, max: undefined }),
        },
        memory: {
          oomScoreAdj: faker.datatype.number({ min: undefined, max: undefined }),
          options: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word()
          ),
          size: faker.random.word(),
          workers: faker.datatype.number({ min: undefined, max: undefined }),
        },
      },
      value: faker.random.word(),
    },
    timeChaos: {
      clockIds: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      duration: faker.random.word(),
      mode: faker.random.word(),
      remoteCluster: faker.random.word(),
      selector: {
        annotationSelectors: {
          clfo3x4a50021q0di1pewcb3o: faker.random.word(),
        },
        fieldSelectors: {
          clfo3x4a50022q0di9yewbqvm: faker.random.word(),
        },
        labelSelectors: {
          clfo3x4a50023q0di27scb2nl: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        nodeSelectors: {
          clfo3x4a50024q0difol70zqg: faker.random.word(),
        },
        nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        pods: {
          clfo3x4a50025q0di4zlmemvh: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1
          ).map(() => faker.random.word()),
        },
      },
      timeOffset: faker.random.word(),
      value: faker.random.word(),
    },
    type: faker.random.word(),
    workflow: {
      entry: faker.random.word(),
      templates: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
        abortWithStatusCheck: faker.datatype.boolean(),
        awsChaos: {
          action: faker.random.word(),
          awsRegion: faker.random.word(),
          deviceName: faker.random.word(),
          duration: faker.random.word(),
          ec2Instance: faker.random.word(),
          endpoint: faker.random.word(),
          remoteCluster: faker.random.word(),
          secretName: faker.random.word(),
          volumeID: faker.random.word(),
        },
        azureChaos: {
          action: faker.random.word(),
          diskName: faker.random.word(),
          duration: faker.random.word(),
          lun: faker.datatype.number({ min: undefined, max: undefined }),
          remoteCluster: faker.random.word(),
          resourceGroupName: faker.random.word(),
          secretName: faker.random.word(),
          subscriptionID: faker.random.word(),
          vmName: faker.random.word(),
        },
        blockChaos: {
          action: faker.random.word(),
          containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word()
          ),
          delay: { correlation: faker.random.word(), jitter: faker.random.word(), latency: faker.random.word() },
          duration: faker.random.word(),
          mode: faker.random.word(),
          remoteCluster: faker.random.word(),
          selector: {
            annotationSelectors: {
              clfo3x4a50026q0di01z878wu: faker.random.word(),
            },
            fieldSelectors: {
              clfo3x4a50027q0diclnvf59o: faker.random.word(),
            },
            labelSelectors: {
              clfo3x4a50028q0digito6298: faker.random.word(),
            },
            namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word()
            ),
            nodeSelectors: {
              clfo3x4a50029q0diev021t78: faker.random.word(),
            },
            nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word()
            ),
            podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => faker.random.word()
            ),
            pods: {
              clfo3x4a5002aq0di06xu2nyo: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1
              ).map(() => faker.random.word()),
            },
          },
          value: faker.random.word(),
          volumeName: faker.random.word(),
        },
        children: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        conditionalBranches: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
          () => ({ expression: faker.random.word(), target: faker.random.word() })
        ),
        deadline: faker.random.word(),
        dnsChaos: {
          action: faker.random.word(),
          containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word()
          ),
          duration: faker.random.word(),
          mode: faker.random.word(),
          patterns: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word()
          ),
          remoteCluster: faker.random.word(),
          selector: {
            annotationSelectors: {
              clfo3x4a5002bq0die825bis1: faker.random.word(),
            },
            fieldSelectors: {
              clfo3x4a5002cq0di0xg243js: faker.random.word(),
            },
            labelSelectors: {
              clfo3x4a5002dq0dif23mba8v: faker.random.word(),
            },
            namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word()
            ),
            nodeSelectors: {
              clfo3x4a5002eq0dicml48r0y: faker.random.word(),
            },
            nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word()
            ),
            podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => faker.random.word()
            ),
            pods: {
              clfo3x4a5002fq0diep3vf77y: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1
              ).map(() => faker.random.word()),
            },
          },
          value: faker.random.word(),
        },
        gcpChaos: {
          action: faker.random.word(),
          deviceNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word()
          ),
          duration: faker.random.word(),
          instance: faker.random.word(),
          project: faker.random.word(),
          remoteCluster: faker.random.word(),
          secretName: faker.random.word(),
          zone: faker.random.word(),
        },
        httpChaos: {
          abort: faker.datatype.boolean(),
          code: faker.datatype.number({ min: undefined, max: undefined }),
          delay: faker.random.word(),
          duration: faker.random.word(),
          method: faker.random.word(),
          mode: faker.random.word(),
          patch: {
            body: { type: faker.random.word(), value: faker.random.word() },
            headers: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              )
            ),
            queries: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              )
            ),
          },
          path: faker.random.word(),
          port: faker.datatype.number({ min: undefined, max: undefined }),
          remoteCluster: faker.random.word(),
          replace: {
            body: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.datatype.number({ min: undefined, max: undefined })
            ),
            code: faker.datatype.number({ min: undefined, max: undefined }),
            headers: {
              clfo3x4a6002gq0dieb8c5yag: faker.random.word(),
            },
            method: faker.random.word(),
            path: faker.random.word(),
            queries: {
              clfo3x4a6002hq0di64b3hwx3: faker.random.word(),
            },
          },
          request_headers: {
            clfo3x4a6002iq0digeiu6wsy: faker.random.word(),
          },
          response_headers: {
            clfo3x4a6002jq0di8yt7blzn: faker.random.word(),
          },
          selector: {
            annotationSelectors: {
              clfo3x4a6002kq0di29odaash: faker.random.word(),
            },
            fieldSelectors: {
              clfo3x4a6002lq0di2xole83g: faker.random.word(),
            },
            labelSelectors: {
              clfo3x4a6002mq0di6m8rc87p: faker.random.word(),
            },
            namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word()
            ),
            nodeSelectors: {
              clfo3x4a6002nq0di1ze37xlb: faker.random.word(),
            },
            nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word()
            ),
            podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => faker.random.word()
            ),
            pods: {
              clfo3x4a6002oq0di914u5slg: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1
              ).map(() => faker.random.word()),
            },
          },
          target: faker.random.word(),
          tls: {
            caName: faker.random.word(),
            certName: faker.random.word(),
            keyName: faker.random.word(),
            secretName: faker.random.word(),
            secretNamespace: faker.random.word(),
          },
          value: faker.random.word(),
        },
        ioChaos: {
          action: faker.random.word(),
          attr: {
            atime: {
              nsec: faker.datatype.number({ min: undefined, max: undefined }),
              sec: faker.datatype.number({ min: undefined, max: undefined }),
            },
            blocks: faker.datatype.number({ min: undefined, max: undefined }),
            ctime: {
              nsec: faker.datatype.number({ min: undefined, max: undefined }),
              sec: faker.datatype.number({ min: undefined, max: undefined }),
            },
            gid: faker.datatype.number({ min: undefined, max: undefined }),
            ino: faker.datatype.number({ min: undefined, max: undefined }),
            kind: faker.random.word(),
            mtime: {
              nsec: faker.datatype.number({ min: undefined, max: undefined }),
              sec: faker.datatype.number({ min: undefined, max: undefined }),
            },
            nlink: faker.datatype.number({ min: undefined, max: undefined }),
            perm: faker.datatype.number({ min: undefined, max: undefined }),
            rdev: faker.datatype.number({ min: undefined, max: undefined }),
            size: faker.datatype.number({ min: undefined, max: undefined }),
            uid: faker.datatype.number({ min: undefined, max: undefined }),
          },
          containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word()
          ),
          delay: faker.random.word(),
          duration: faker.random.word(),
          errno: faker.datatype.number({ min: undefined, max: undefined }),
          methods: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word()
          ),
          mistake: {
            filling: faker.random.word(),
            maxLength: faker.datatype.number({ min: undefined, max: undefined }),
            maxOccurrences: faker.datatype.number({ min: undefined, max: undefined }),
          },
          mode: faker.random.word(),
          path: faker.random.word(),
          percent: faker.datatype.number({ min: undefined, max: undefined }),
          remoteCluster: faker.random.word(),
          selector: {
            annotationSelectors: {
              clfo3x4a6002pq0dihpd28ydn: faker.random.word(),
            },
            fieldSelectors: {
              clfo3x4a6002qq0didy11eu50: faker.random.word(),
            },
            labelSelectors: {
              clfo3x4a6002rq0diad54apok: faker.random.word(),
            },
            namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word()
            ),
            nodeSelectors: {
              clfo3x4a6002sq0di48o3432s: faker.random.word(),
            },
            nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word()
            ),
            podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => faker.random.word()
            ),
            pods: {
              clfo3x4a6002tq0dighqd34gr: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1
              ).map(() => faker.random.word()),
            },
          },
          value: faker.random.word(),
          volumePath: faker.random.word(),
        },
        jvmChaos: {
          action: faker.random.word(),
          class: faker.random.word(),
          containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word()
          ),
          cpuCount: faker.datatype.number({ min: undefined, max: undefined }),
          database: faker.random.word(),
          duration: faker.random.word(),
          exception: faker.random.word(),
          latency: faker.datatype.number({ min: undefined, max: undefined }),
          memType: faker.random.word(),
          method: faker.random.word(),
          mode: faker.random.word(),
          mysqlConnectorVersion: faker.random.word(),
          name: faker.random.word(),
          pid: faker.datatype.number({ min: undefined, max: undefined }),
          port: faker.datatype.number({ min: undefined, max: undefined }),
          remoteCluster: faker.random.word(),
          ruleData: faker.random.word(),
          selector: {
            annotationSelectors: {
              clfo3x4a6002uq0di330e94nk: faker.random.word(),
            },
            fieldSelectors: {
              clfo3x4a6002vq0did2b099xt: faker.random.word(),
            },
            labelSelectors: {
              clfo3x4a6002wq0dic18xcj18: faker.random.word(),
            },
            namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word()
            ),
            nodeSelectors: {
              clfo3x4a6002xq0di2ul2a1n8: faker.random.word(),
            },
            nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word()
            ),
            podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => faker.random.word()
            ),
            pods: {
              clfo3x4a6002yq0di0rfb1n8q: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1
              ).map(() => faker.random.word()),
            },
          },
          sqlType: faker.random.word(),
          table: faker.random.word(),
          value: faker.random.word(),
        },
        kernelChaos: {
          containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word()
          ),
          duration: faker.random.word(),
          failKernRequest: {
            callchain: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
              funcname: faker.random.word(),
              parameters: faker.random.word(),
              predicate: faker.random.word(),
            })),
            failtype: faker.datatype.number({ min: undefined, max: undefined }),
            headers: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word()
            ),
            probability: faker.datatype.number({ min: undefined, max: undefined }),
            times: faker.datatype.number({ min: undefined, max: undefined }),
          },
          mode: faker.random.word(),
          remoteCluster: faker.random.word(),
          selector: {
            annotationSelectors: {
              clfo3x4a6002zq0di00zqh4r2: faker.random.word(),
            },
            fieldSelectors: {
              clfo3x4a60030q0di3ky65904: faker.random.word(),
            },
            labelSelectors: {
              clfo3x4a60031q0di5k7wb7cw: faker.random.word(),
            },
            namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word()
            ),
            nodeSelectors: {
              clfo3x4a60032q0di0mu81hgz: faker.random.word(),
            },
            nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word()
            ),
            podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => faker.random.word()
            ),
            pods: {
              clfo3x4a60033q0difxdlev54: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1
              ).map(() => faker.random.word()),
            },
          },
          value: faker.random.word(),
        },
        name: faker.random.word(),
        networkChaos: {
          action: faker.random.word(),
          bandwidth: {
            buffer: faker.datatype.number({ min: undefined, max: undefined }),
            limit: faker.datatype.number({ min: undefined, max: undefined }),
            minburst: faker.datatype.number({ min: undefined, max: undefined }),
            peakrate: faker.datatype.number({ min: undefined, max: undefined }),
            rate: faker.random.word(),
          },
          corrupt: { correlation: faker.random.word(), corrupt: faker.random.word() },
          delay: {
            correlation: faker.random.word(),
            jitter: faker.random.word(),
            latency: faker.random.word(),
            reorder: {
              correlation: faker.random.word(),
              gap: faker.datatype.number({ min: undefined, max: undefined }),
              reorder: faker.random.word(),
            },
          },
          device: faker.random.word(),
          direction: faker.random.word(),
          duplicate: { correlation: faker.random.word(), duplicate: faker.random.word() },
          duration: faker.random.word(),
          externalTargets: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word()
          ),
          loss: { correlation: faker.random.word(), loss: faker.random.word() },
          mode: faker.random.word(),
          remoteCluster: faker.random.word(),
          selector: {
            annotationSelectors: {
              clfo3x4a60034q0dieqwb36ba: faker.random.word(),
            },
            fieldSelectors: {
              clfo3x4a60035q0di1fzcgtxz: faker.random.word(),
            },
            labelSelectors: {
              clfo3x4a60036q0di885dc238: faker.random.word(),
            },
            namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word()
            ),
            nodeSelectors: {
              clfo3x4a60037q0di3x7ncxwz: faker.random.word(),
            },
            nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word()
            ),
            podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => faker.random.word()
            ),
            pods: {
              clfo3x4a60038q0didkcq4igo: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1
              ).map(() => faker.random.word()),
            },
          },
          target: {
            mode: faker.random.word(),
            selector: {
              annotationSelectors: {
                clfo3x4a60039q0dihnl8fr57: faker.random.word(),
              },
              fieldSelectors: {
                clfo3x4a6003aq0dia9sz5s1t: faker.random.word(),
              },
              labelSelectors: {
                clfo3x4a6003bq0di3c9lcldd: faker.random.word(),
              },
              namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              ),
              nodeSelectors: {
                clfo3x4a6003cq0di92nwdpe8: faker.random.word(),
              },
              nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              ),
              podPhaseSelectors: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1
              ).map(() => faker.random.word()),
              pods: {
                clfo3x4a7003dq0di98411urv: Array.from(
                  { length: faker.datatype.number({ min: 1, max: 10 }) },
                  (_, i) => i + 1
                ).map(() => faker.random.word()),
              },
            },
            value: faker.random.word(),
          },
          targetDevice: faker.random.word(),
          value: faker.random.word(),
        },
        physicalmachineChaos: {
          action: faker.random.word(),
          address: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word()
          ),
          clock: {
            'clock-ids-slice': faker.random.word(),
            pid: faker.datatype.number({ min: undefined, max: undefined }),
            'time-offset': faker.random.word(),
          },
          'disk-fill': {
            'fill-by-fallocate': faker.datatype.boolean(),
            path: faker.random.word(),
            size: faker.random.word(),
          },
          'disk-read-payload': {
            path: faker.random.word(),
            'payload-process-num': faker.datatype.number({ min: undefined, max: undefined }),
            size: faker.random.word(),
          },
          'disk-write-payload': {
            path: faker.random.word(),
            'payload-process-num': faker.datatype.number({ min: undefined, max: undefined }),
            size: faker.random.word(),
          },
          duration: faker.random.word(),
          'file-append': {
            count: faker.datatype.number({ min: undefined, max: undefined }),
            data: faker.random.word(),
            'file-name': faker.random.word(),
          },
          'file-create': { 'dir-name': faker.random.word(), 'file-name': faker.random.word() },
          'file-delete': { 'dir-name': faker.random.word(), 'file-name': faker.random.word() },
          'file-modify': {
            'file-name': faker.random.word(),
            privilege: faker.datatype.number({ min: undefined, max: undefined }),
          },
          'file-rename': { 'dest-file': faker.random.word(), 'source-file': faker.random.word() },
          'file-replace': {
            'dest-string': faker.random.word(),
            'file-name': faker.random.word(),
            line: faker.datatype.number({ min: undefined, max: undefined }),
            'origin-string': faker.random.word(),
          },
          'http-abort': {
            code: faker.random.word(),
            method: faker.random.word(),
            path: faker.random.word(),
            port: faker.datatype.number({ min: undefined, max: undefined }),
            proxy_ports: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.datatype.number({ min: undefined, max: undefined })
            ),
            target: faker.random.word(),
          },
          'http-config': { file_path: faker.random.word() },
          'http-delay': {
            code: faker.random.word(),
            delay: faker.random.word(),
            method: faker.random.word(),
            path: faker.random.word(),
            port: faker.datatype.number({ min: undefined, max: undefined }),
            proxy_ports: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.datatype.number({ min: undefined, max: undefined })
            ),
            target: faker.random.word(),
          },
          'http-request': {
            count: faker.datatype.number({ min: undefined, max: undefined }),
            'enable-conn-pool': faker.datatype.boolean(),
            url: faker.random.word(),
          },
          'jvm-exception': {
            class: faker.random.word(),
            exception: faker.random.word(),
            method: faker.random.word(),
            pid: faker.datatype.number({ min: undefined, max: undefined }),
            port: faker.datatype.number({ min: undefined, max: undefined }),
          },
          'jvm-gc': {
            pid: faker.datatype.number({ min: undefined, max: undefined }),
            port: faker.datatype.number({ min: undefined, max: undefined }),
          },
          'jvm-latency': {
            class: faker.random.word(),
            latency: faker.datatype.number({ min: undefined, max: undefined }),
            method: faker.random.word(),
            pid: faker.datatype.number({ min: undefined, max: undefined }),
            port: faker.datatype.number({ min: undefined, max: undefined }),
          },
          'jvm-mysql': {
            database: faker.random.word(),
            exception: faker.random.word(),
            latency: faker.datatype.number({ min: undefined, max: undefined }),
            mysqlConnectorVersion: faker.random.word(),
            pid: faker.datatype.number({ min: undefined, max: undefined }),
            port: faker.datatype.number({ min: undefined, max: undefined }),
            sqlType: faker.random.word(),
            table: faker.random.word(),
          },
          'jvm-return': {
            class: faker.random.word(),
            method: faker.random.word(),
            pid: faker.datatype.number({ min: undefined, max: undefined }),
            port: faker.datatype.number({ min: undefined, max: undefined }),
            value: faker.random.word(),
          },
          'jvm-rule-data': {
            pid: faker.datatype.number({ min: undefined, max: undefined }),
            port: faker.datatype.number({ min: undefined, max: undefined }),
            'rule-data': faker.random.word(),
          },
          'jvm-stress': {
            'cpu-count': faker.datatype.number({ min: undefined, max: undefined }),
            'mem-type': faker.random.word(),
            pid: faker.datatype.number({ min: undefined, max: undefined }),
            port: faker.datatype.number({ min: undefined, max: undefined }),
          },
          'kafka-fill': {
            host: faker.random.word(),
            maxBytes: faker.datatype.number({ min: undefined, max: undefined }),
            messageSize: faker.datatype.number({ min: undefined, max: undefined }),
            password: faker.random.word(),
            port: faker.datatype.number({ min: undefined, max: undefined }),
            reloadCommand: faker.random.word(),
            topic: faker.random.word(),
            username: faker.random.word(),
          },
          'kafka-flood': {
            host: faker.random.word(),
            messageSize: faker.datatype.number({ min: undefined, max: undefined }),
            password: faker.random.word(),
            port: faker.datatype.number({ min: undefined, max: undefined }),
            threads: faker.datatype.number({ min: undefined, max: undefined }),
            topic: faker.random.word(),
            username: faker.random.word(),
          },
          'kafka-io': {
            configFile: faker.random.word(),
            nonReadable: faker.datatype.boolean(),
            nonWritable: faker.datatype.boolean(),
            topic: faker.random.word(),
          },
          mode: faker.random.word(),
          'network-bandwidth': {
            buffer: faker.datatype.number({ min: undefined, max: undefined }),
            device: faker.random.word(),
            hostname: faker.random.word(),
            'ip-address': faker.random.word(),
            limit: faker.datatype.number({ min: undefined, max: undefined }),
            minburst: faker.datatype.number({ min: undefined, max: undefined }),
            peakrate: faker.datatype.number({ min: undefined, max: undefined }),
            rate: faker.random.word(),
          },
          'network-corrupt': {
            correlation: faker.random.word(),
            device: faker.random.word(),
            'egress-port': faker.random.word(),
            hostname: faker.random.word(),
            'ip-address': faker.random.word(),
            'ip-protocol': faker.random.word(),
            percent: faker.random.word(),
            'source-port': faker.random.word(),
          },
          'network-delay': {
            'accept-tcp-flags': faker.random.word(),
            correlation: faker.random.word(),
            device: faker.random.word(),
            'egress-port': faker.random.word(),
            hostname: faker.random.word(),
            'ip-address': faker.random.word(),
            'ip-protocol': faker.random.word(),
            jitter: faker.random.word(),
            latency: faker.random.word(),
            'source-port': faker.random.word(),
          },
          'network-dns': {
            'dns-domain-name': faker.random.word(),
            'dns-ip': faker.random.word(),
            'dns-server': faker.random.word(),
          },
          'network-down': { device: faker.random.word(), duration: faker.random.word() },
          'network-duplicate': {
            correlation: faker.random.word(),
            device: faker.random.word(),
            'egress-port': faker.random.word(),
            hostname: faker.random.word(),
            'ip-address': faker.random.word(),
            'ip-protocol': faker.random.word(),
            percent: faker.random.word(),
            'source-port': faker.random.word(),
          },
          'network-flood': {
            duration: faker.random.word(),
            'ip-address': faker.random.word(),
            parallel: faker.datatype.number({ min: undefined, max: undefined }),
            port: faker.random.word(),
            rate: faker.random.word(),
          },
          'network-loss': {
            correlation: faker.random.word(),
            device: faker.random.word(),
            'egress-port': faker.random.word(),
            hostname: faker.random.word(),
            'ip-address': faker.random.word(),
            'ip-protocol': faker.random.word(),
            percent: faker.random.word(),
            'source-port': faker.random.word(),
          },
          'network-partition': {
            'accept-tcp-flags': faker.random.word(),
            device: faker.random.word(),
            direction: faker.random.word(),
            hostname: faker.random.word(),
            'ip-address': faker.random.word(),
            'ip-protocol': faker.random.word(),
          },
          process: {
            process: faker.random.word(),
            recoverCmd: faker.random.word(),
            signal: faker.datatype.number({ min: undefined, max: undefined }),
          },
          'redis-cacheLimit': {
            addr: faker.random.word(),
            cacheSize: faker.random.word(),
            password: faker.random.word(),
            percent: faker.random.word(),
          },
          'redis-expiration': {
            addr: faker.random.word(),
            expiration: faker.random.word(),
            key: faker.random.word(),
            option: faker.random.word(),
            password: faker.random.word(),
          },
          'redis-penetration': {
            addr: faker.random.word(),
            password: faker.random.word(),
            requestNum: faker.datatype.number({ min: undefined, max: undefined }),
          },
          'redis-restart': {
            addr: faker.random.word(),
            conf: faker.random.word(),
            flushConfig: faker.datatype.boolean(),
            password: faker.random.word(),
            redisPath: faker.datatype.boolean(),
          },
          'redis-stop': {
            addr: faker.random.word(),
            conf: faker.random.word(),
            flushConfig: faker.datatype.boolean(),
            password: faker.random.word(),
            redisPath: faker.datatype.boolean(),
          },
          remoteCluster: faker.random.word(),
          selector: {
            annotationSelectors: {
              clfo3x4a8003eq0di8e6uhww8: faker.random.word(),
            },
            fieldSelectors: {
              clfo3x4a8003fq0die8bb7c7w: faker.random.word(),
            },
            labelSelectors: {
              clfo3x4a8003gq0di2aqe6ogg: faker.random.word(),
            },
            namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word()
            ),
            physicalMachines: {
              clfo3x4a8003hq0di1odnf5sd: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1
              ).map(() => faker.random.word()),
            },
          },
          'stress-cpu': {
            load: faker.datatype.number({ min: undefined, max: undefined }),
            options: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word()
            ),
            workers: faker.datatype.number({ min: undefined, max: undefined }),
          },
          'stress-mem': {
            options: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word()
            ),
            size: faker.random.word(),
          },
          user_defined: { attackCmd: faker.random.word(), recoverCmd: faker.random.word() },
          value: faker.random.word(),
          vm: { 'vm-name': faker.random.word() },
        },
        podChaos: {
          action: faker.random.word(),
          containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word()
          ),
          duration: faker.random.word(),
          gracePeriod: faker.datatype.number({ min: undefined, max: undefined }),
          mode: faker.random.word(),
          remoteCluster: faker.random.word(),
          selector: {
            annotationSelectors: {
              clfo3x4a8003iq0di0mhd9dhh: faker.random.word(),
            },
            fieldSelectors: {
              clfo3x4a8003jq0di5vz765gs: faker.random.word(),
            },
            labelSelectors: {
              clfo3x4a8003kq0di41rwhein: faker.random.word(),
            },
            namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word()
            ),
            nodeSelectors: {
              clfo3x4a8003lq0difpxz8k9w: faker.random.word(),
            },
            nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word()
            ),
            podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => faker.random.word()
            ),
            pods: {
              clfo3x4a8003mq0di8rmtb5k7: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1
              ).map(() => faker.random.word()),
            },
          },
          value: faker.random.word(),
        },
        schedule: {
          awsChaos: {
            action: faker.random.word(),
            awsRegion: faker.random.word(),
            deviceName: faker.random.word(),
            duration: faker.random.word(),
            ec2Instance: faker.random.word(),
            endpoint: faker.random.word(),
            remoteCluster: faker.random.word(),
            secretName: faker.random.word(),
            volumeID: faker.random.word(),
          },
          azureChaos: {
            action: faker.random.word(),
            diskName: faker.random.word(),
            duration: faker.random.word(),
            lun: faker.datatype.number({ min: undefined, max: undefined }),
            remoteCluster: faker.random.word(),
            resourceGroupName: faker.random.word(),
            secretName: faker.random.word(),
            subscriptionID: faker.random.word(),
            vmName: faker.random.word(),
          },
          blockChaos: {
            action: faker.random.word(),
            containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => faker.random.word()
            ),
            delay: { correlation: faker.random.word(), jitter: faker.random.word(), latency: faker.random.word() },
            duration: faker.random.word(),
            mode: faker.random.word(),
            remoteCluster: faker.random.word(),
            selector: {
              annotationSelectors: {
                clfo3x4a8003nq0difaj3fqha: faker.random.word(),
              },
              fieldSelectors: {
                clfo3x4a8003oq0di1xlhcnvy: faker.random.word(),
              },
              labelSelectors: {
                clfo3x4a8003pq0diezs3hfxn: faker.random.word(),
              },
              namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              ),
              nodeSelectors: {
                clfo3x4a8003qq0di7ttyczo5: faker.random.word(),
              },
              nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              ),
              podPhaseSelectors: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1
              ).map(() => faker.random.word()),
              pods: {
                clfo3x4a8003rq0dihott4eql: Array.from(
                  { length: faker.datatype.number({ min: 1, max: 10 }) },
                  (_, i) => i + 1
                ).map(() => faker.random.word()),
              },
            },
            value: faker.random.word(),
            volumeName: faker.random.word(),
          },
          concurrencyPolicy: faker.random.word(),
          dnsChaos: {
            action: faker.random.word(),
            containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => faker.random.word()
            ),
            duration: faker.random.word(),
            mode: faker.random.word(),
            patterns: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word()
            ),
            remoteCluster: faker.random.word(),
            selector: {
              annotationSelectors: {
                clfo3x4a8003sq0dih2xihfe3: faker.random.word(),
              },
              fieldSelectors: {
                clfo3x4a8003tq0die5yyhttp: faker.random.word(),
              },
              labelSelectors: {
                clfo3x4a8003uq0di6ole99j5: faker.random.word(),
              },
              namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              ),
              nodeSelectors: {
                clfo3x4a8003vq0di0ccudwx4: faker.random.word(),
              },
              nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              ),
              podPhaseSelectors: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1
              ).map(() => faker.random.word()),
              pods: {
                clfo3x4a8003wq0dig0f6ay08: Array.from(
                  { length: faker.datatype.number({ min: 1, max: 10 }) },
                  (_, i) => i + 1
                ).map(() => faker.random.word()),
              },
            },
            value: faker.random.word(),
          },
          gcpChaos: {
            action: faker.random.word(),
            deviceNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word()
            ),
            duration: faker.random.word(),
            instance: faker.random.word(),
            project: faker.random.word(),
            remoteCluster: faker.random.word(),
            secretName: faker.random.word(),
            zone: faker.random.word(),
          },
          historyLimit: faker.datatype.number({ min: undefined, max: undefined }),
          httpChaos: {
            abort: faker.datatype.boolean(),
            code: faker.datatype.number({ min: undefined, max: undefined }),
            delay: faker.random.word(),
            duration: faker.random.word(),
            method: faker.random.word(),
            mode: faker.random.word(),
            patch: {
              body: { type: faker.random.word(), value: faker.random.word() },
              headers: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                  faker.random.word()
                )
              ),
              queries: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                  faker.random.word()
                )
              ),
            },
            path: faker.random.word(),
            port: faker.datatype.number({ min: undefined, max: undefined }),
            remoteCluster: faker.random.word(),
            replace: {
              body: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.datatype.number({ min: undefined, max: undefined })
              ),
              code: faker.datatype.number({ min: undefined, max: undefined }),
              headers: {
                clfo3x4a8003xq0dibl6s09w5: faker.random.word(),
              },
              method: faker.random.word(),
              path: faker.random.word(),
              queries: {
                clfo3x4a8003yq0digi4e6nvo: faker.random.word(),
              },
            },
            request_headers: {
              clfo3x4a8003zq0did6tfdvan: faker.random.word(),
            },
            response_headers: {
              clfo3x4a80040q0dib0m94ug5: faker.random.word(),
            },
            selector: {
              annotationSelectors: {
                clfo3x4a80041q0di9vsufs0y: faker.random.word(),
              },
              fieldSelectors: {
                clfo3x4a80042q0di4x0aeq3g: faker.random.word(),
              },
              labelSelectors: {
                clfo3x4a80043q0die5ci3wi6: faker.random.word(),
              },
              namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              ),
              nodeSelectors: {
                clfo3x4a80044q0di43bc9jnr: faker.random.word(),
              },
              nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              ),
              podPhaseSelectors: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1
              ).map(() => faker.random.word()),
              pods: {
                clfo3x4a80045q0di6xbbggng: Array.from(
                  { length: faker.datatype.number({ min: 1, max: 10 }) },
                  (_, i) => i + 1
                ).map(() => faker.random.word()),
              },
            },
            target: faker.random.word(),
            tls: {
              caName: faker.random.word(),
              certName: faker.random.word(),
              keyName: faker.random.word(),
              secretName: faker.random.word(),
              secretNamespace: faker.random.word(),
            },
            value: faker.random.word(),
          },
          ioChaos: {
            action: faker.random.word(),
            attr: {
              atime: {
                nsec: faker.datatype.number({ min: undefined, max: undefined }),
                sec: faker.datatype.number({ min: undefined, max: undefined }),
              },
              blocks: faker.datatype.number({ min: undefined, max: undefined }),
              ctime: {
                nsec: faker.datatype.number({ min: undefined, max: undefined }),
                sec: faker.datatype.number({ min: undefined, max: undefined }),
              },
              gid: faker.datatype.number({ min: undefined, max: undefined }),
              ino: faker.datatype.number({ min: undefined, max: undefined }),
              kind: faker.random.word(),
              mtime: {
                nsec: faker.datatype.number({ min: undefined, max: undefined }),
                sec: faker.datatype.number({ min: undefined, max: undefined }),
              },
              nlink: faker.datatype.number({ min: undefined, max: undefined }),
              perm: faker.datatype.number({ min: undefined, max: undefined }),
              rdev: faker.datatype.number({ min: undefined, max: undefined }),
              size: faker.datatype.number({ min: undefined, max: undefined }),
              uid: faker.datatype.number({ min: undefined, max: undefined }),
            },
            containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => faker.random.word()
            ),
            delay: faker.random.word(),
            duration: faker.random.word(),
            errno: faker.datatype.number({ min: undefined, max: undefined }),
            methods: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word()
            ),
            mistake: {
              filling: faker.random.word(),
              maxLength: faker.datatype.number({ min: undefined, max: undefined }),
              maxOccurrences: faker.datatype.number({ min: undefined, max: undefined }),
            },
            mode: faker.random.word(),
            path: faker.random.word(),
            percent: faker.datatype.number({ min: undefined, max: undefined }),
            remoteCluster: faker.random.word(),
            selector: {
              annotationSelectors: {
                clfo3x4a90046q0dic6pxb1d3: faker.random.word(),
              },
              fieldSelectors: {
                clfo3x4a90047q0di727e8wv3: faker.random.word(),
              },
              labelSelectors: {
                clfo3x4a90048q0di4j8y59nj: faker.random.word(),
              },
              namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              ),
              nodeSelectors: {
                clfo3x4a90049q0dicdprdobz: faker.random.word(),
              },
              nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              ),
              podPhaseSelectors: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1
              ).map(() => faker.random.word()),
              pods: {
                clfo3x4a9004aq0did5qv9ycc: Array.from(
                  { length: faker.datatype.number({ min: 1, max: 10 }) },
                  (_, i) => i + 1
                ).map(() => faker.random.word()),
              },
            },
            value: faker.random.word(),
            volumePath: faker.random.word(),
          },
          jvmChaos: {
            action: faker.random.word(),
            class: faker.random.word(),
            containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => faker.random.word()
            ),
            cpuCount: faker.datatype.number({ min: undefined, max: undefined }),
            database: faker.random.word(),
            duration: faker.random.word(),
            exception: faker.random.word(),
            latency: faker.datatype.number({ min: undefined, max: undefined }),
            memType: faker.random.word(),
            method: faker.random.word(),
            mode: faker.random.word(),
            mysqlConnectorVersion: faker.random.word(),
            name: faker.random.word(),
            pid: faker.datatype.number({ min: undefined, max: undefined }),
            port: faker.datatype.number({ min: undefined, max: undefined }),
            remoteCluster: faker.random.word(),
            ruleData: faker.random.word(),
            selector: {
              annotationSelectors: {
                clfo3x4a9004bq0di8n6phzm2: faker.random.word(),
              },
              fieldSelectors: {
                clfo3x4a9004cq0didcsadf6f: faker.random.word(),
              },
              labelSelectors: {
                clfo3x4a9004dq0di19auhlfe: faker.random.word(),
              },
              namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              ),
              nodeSelectors: {
                clfo3x4a9004eq0di7yxd2f9q: faker.random.word(),
              },
              nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              ),
              podPhaseSelectors: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1
              ).map(() => faker.random.word()),
              pods: {
                clfo3x4a9004fq0dihiwx57hd: Array.from(
                  { length: faker.datatype.number({ min: 1, max: 10 }) },
                  (_, i) => i + 1
                ).map(() => faker.random.word()),
              },
            },
            sqlType: faker.random.word(),
            table: faker.random.word(),
            value: faker.random.word(),
          },
          kernelChaos: {
            containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => faker.random.word()
            ),
            duration: faker.random.word(),
            failKernRequest: {
              callchain: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                () => ({
                  funcname: faker.random.word(),
                  parameters: faker.random.word(),
                  predicate: faker.random.word(),
                })
              ),
              failtype: faker.datatype.number({ min: undefined, max: undefined }),
              headers: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              ),
              probability: faker.datatype.number({ min: undefined, max: undefined }),
              times: faker.datatype.number({ min: undefined, max: undefined }),
            },
            mode: faker.random.word(),
            remoteCluster: faker.random.word(),
            selector: {
              annotationSelectors: {
                clfo3x4a9004gq0di93kzeffw: faker.random.word(),
              },
              fieldSelectors: {
                clfo3x4a9004hq0di4fhz9l47: faker.random.word(),
              },
              labelSelectors: {
                clfo3x4a9004iq0dics0yf64h: faker.random.word(),
              },
              namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              ),
              nodeSelectors: {
                clfo3x4a9004jq0dib2etaien: faker.random.word(),
              },
              nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              ),
              podPhaseSelectors: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1
              ).map(() => faker.random.word()),
              pods: {
                clfo3x4a9004kq0dicael92h0: Array.from(
                  { length: faker.datatype.number({ min: 1, max: 10 }) },
                  (_, i) => i + 1
                ).map(() => faker.random.word()),
              },
            },
            value: faker.random.word(),
          },
          networkChaos: {
            action: faker.random.word(),
            bandwidth: {
              buffer: faker.datatype.number({ min: undefined, max: undefined }),
              limit: faker.datatype.number({ min: undefined, max: undefined }),
              minburst: faker.datatype.number({ min: undefined, max: undefined }),
              peakrate: faker.datatype.number({ min: undefined, max: undefined }),
              rate: faker.random.word(),
            },
            corrupt: { correlation: faker.random.word(), corrupt: faker.random.word() },
            delay: {
              correlation: faker.random.word(),
              jitter: faker.random.word(),
              latency: faker.random.word(),
              reorder: {
                correlation: faker.random.word(),
                gap: faker.datatype.number({ min: undefined, max: undefined }),
                reorder: faker.random.word(),
              },
            },
            device: faker.random.word(),
            direction: faker.random.word(),
            duplicate: { correlation: faker.random.word(), duplicate: faker.random.word() },
            duration: faker.random.word(),
            externalTargets: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => faker.random.word()
            ),
            loss: { correlation: faker.random.word(), loss: faker.random.word() },
            mode: faker.random.word(),
            remoteCluster: faker.random.word(),
            selector: {
              annotationSelectors: {
                clfo3x4a9004lq0di4hck8x4p: faker.random.word(),
              },
              fieldSelectors: {
                clfo3x4a9004mq0di9w8s3bck: faker.random.word(),
              },
              labelSelectors: {
                clfo3x4a9004nq0did2v699jq: faker.random.word(),
              },
              namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              ),
              nodeSelectors: {
                clfo3x4a9004oq0di18f71itk: faker.random.word(),
              },
              nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              ),
              podPhaseSelectors: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1
              ).map(() => faker.random.word()),
              pods: {
                clfo3x4a9004pq0dia57melwk: Array.from(
                  { length: faker.datatype.number({ min: 1, max: 10 }) },
                  (_, i) => i + 1
                ).map(() => faker.random.word()),
              },
            },
            target: {
              mode: faker.random.word(),
              selector: {
                annotationSelectors: {
                  clfo3x4a9004qq0dih98q5aks: faker.random.word(),
                },
                fieldSelectors: {
                  clfo3x4a9004rq0diehu91yfv: faker.random.word(),
                },
                labelSelectors: {
                  clfo3x4a9004sq0di4j8udzoe: faker.random.word(),
                },
                namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                  () => faker.random.word()
                ),
                nodeSelectors: {
                  clfo3x4a9004tq0di8l3o0bd8: faker.random.word(),
                },
                nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                  faker.random.word()
                ),
                podPhaseSelectors: Array.from(
                  { length: faker.datatype.number({ min: 1, max: 10 }) },
                  (_, i) => i + 1
                ).map(() => faker.random.word()),
                pods: {
                  clfo3x4a9004uq0dif20xgtgi: Array.from(
                    { length: faker.datatype.number({ min: 1, max: 10 }) },
                    (_, i) => i + 1
                  ).map(() => faker.random.word()),
                },
              },
              value: faker.random.word(),
            },
            targetDevice: faker.random.word(),
            value: faker.random.word(),
          },
          physicalmachineChaos: {
            action: faker.random.word(),
            address: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word()
            ),
            clock: {
              'clock-ids-slice': faker.random.word(),
              pid: faker.datatype.number({ min: undefined, max: undefined }),
              'time-offset': faker.random.word(),
            },
            'disk-fill': {
              'fill-by-fallocate': faker.datatype.boolean(),
              path: faker.random.word(),
              size: faker.random.word(),
            },
            'disk-read-payload': {
              path: faker.random.word(),
              'payload-process-num': faker.datatype.number({ min: undefined, max: undefined }),
              size: faker.random.word(),
            },
            'disk-write-payload': {
              path: faker.random.word(),
              'payload-process-num': faker.datatype.number({ min: undefined, max: undefined }),
              size: faker.random.word(),
            },
            duration: faker.random.word(),
            'file-append': {
              count: faker.datatype.number({ min: undefined, max: undefined }),
              data: faker.random.word(),
              'file-name': faker.random.word(),
            },
            'file-create': { 'dir-name': faker.random.word(), 'file-name': faker.random.word() },
            'file-delete': { 'dir-name': faker.random.word(), 'file-name': faker.random.word() },
            'file-modify': {
              'file-name': faker.random.word(),
              privilege: faker.datatype.number({ min: undefined, max: undefined }),
            },
            'file-rename': { 'dest-file': faker.random.word(), 'source-file': faker.random.word() },
            'file-replace': {
              'dest-string': faker.random.word(),
              'file-name': faker.random.word(),
              line: faker.datatype.number({ min: undefined, max: undefined }),
              'origin-string': faker.random.word(),
            },
            'http-abort': {
              code: faker.random.word(),
              method: faker.random.word(),
              path: faker.random.word(),
              port: faker.datatype.number({ min: undefined, max: undefined }),
              proxy_ports: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.datatype.number({ min: undefined, max: undefined })
              ),
              target: faker.random.word(),
            },
            'http-config': { file_path: faker.random.word() },
            'http-delay': {
              code: faker.random.word(),
              delay: faker.random.word(),
              method: faker.random.word(),
              path: faker.random.word(),
              port: faker.datatype.number({ min: undefined, max: undefined }),
              proxy_ports: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.datatype.number({ min: undefined, max: undefined })
              ),
              target: faker.random.word(),
            },
            'http-request': {
              count: faker.datatype.number({ min: undefined, max: undefined }),
              'enable-conn-pool': faker.datatype.boolean(),
              url: faker.random.word(),
            },
            'jvm-exception': {
              class: faker.random.word(),
              exception: faker.random.word(),
              method: faker.random.word(),
              pid: faker.datatype.number({ min: undefined, max: undefined }),
              port: faker.datatype.number({ min: undefined, max: undefined }),
            },
            'jvm-gc': {
              pid: faker.datatype.number({ min: undefined, max: undefined }),
              port: faker.datatype.number({ min: undefined, max: undefined }),
            },
            'jvm-latency': {
              class: faker.random.word(),
              latency: faker.datatype.number({ min: undefined, max: undefined }),
              method: faker.random.word(),
              pid: faker.datatype.number({ min: undefined, max: undefined }),
              port: faker.datatype.number({ min: undefined, max: undefined }),
            },
            'jvm-mysql': {
              database: faker.random.word(),
              exception: faker.random.word(),
              latency: faker.datatype.number({ min: undefined, max: undefined }),
              mysqlConnectorVersion: faker.random.word(),
              pid: faker.datatype.number({ min: undefined, max: undefined }),
              port: faker.datatype.number({ min: undefined, max: undefined }),
              sqlType: faker.random.word(),
              table: faker.random.word(),
            },
            'jvm-return': {
              class: faker.random.word(),
              method: faker.random.word(),
              pid: faker.datatype.number({ min: undefined, max: undefined }),
              port: faker.datatype.number({ min: undefined, max: undefined }),
              value: faker.random.word(),
            },
            'jvm-rule-data': {
              pid: faker.datatype.number({ min: undefined, max: undefined }),
              port: faker.datatype.number({ min: undefined, max: undefined }),
              'rule-data': faker.random.word(),
            },
            'jvm-stress': {
              'cpu-count': faker.datatype.number({ min: undefined, max: undefined }),
              'mem-type': faker.random.word(),
              pid: faker.datatype.number({ min: undefined, max: undefined }),
              port: faker.datatype.number({ min: undefined, max: undefined }),
            },
            'kafka-fill': {
              host: faker.random.word(),
              maxBytes: faker.datatype.number({ min: undefined, max: undefined }),
              messageSize: faker.datatype.number({ min: undefined, max: undefined }),
              password: faker.random.word(),
              port: faker.datatype.number({ min: undefined, max: undefined }),
              reloadCommand: faker.random.word(),
              topic: faker.random.word(),
              username: faker.random.word(),
            },
            'kafka-flood': {
              host: faker.random.word(),
              messageSize: faker.datatype.number({ min: undefined, max: undefined }),
              password: faker.random.word(),
              port: faker.datatype.number({ min: undefined, max: undefined }),
              threads: faker.datatype.number({ min: undefined, max: undefined }),
              topic: faker.random.word(),
              username: faker.random.word(),
            },
            'kafka-io': {
              configFile: faker.random.word(),
              nonReadable: faker.datatype.boolean(),
              nonWritable: faker.datatype.boolean(),
              topic: faker.random.word(),
            },
            mode: faker.random.word(),
            'network-bandwidth': {
              buffer: faker.datatype.number({ min: undefined, max: undefined }),
              device: faker.random.word(),
              hostname: faker.random.word(),
              'ip-address': faker.random.word(),
              limit: faker.datatype.number({ min: undefined, max: undefined }),
              minburst: faker.datatype.number({ min: undefined, max: undefined }),
              peakrate: faker.datatype.number({ min: undefined, max: undefined }),
              rate: faker.random.word(),
            },
            'network-corrupt': {
              correlation: faker.random.word(),
              device: faker.random.word(),
              'egress-port': faker.random.word(),
              hostname: faker.random.word(),
              'ip-address': faker.random.word(),
              'ip-protocol': faker.random.word(),
              percent: faker.random.word(),
              'source-port': faker.random.word(),
            },
            'network-delay': {
              'accept-tcp-flags': faker.random.word(),
              correlation: faker.random.word(),
              device: faker.random.word(),
              'egress-port': faker.random.word(),
              hostname: faker.random.word(),
              'ip-address': faker.random.word(),
              'ip-protocol': faker.random.word(),
              jitter: faker.random.word(),
              latency: faker.random.word(),
              'source-port': faker.random.word(),
            },
            'network-dns': {
              'dns-domain-name': faker.random.word(),
              'dns-ip': faker.random.word(),
              'dns-server': faker.random.word(),
            },
            'network-down': { device: faker.random.word(), duration: faker.random.word() },
            'network-duplicate': {
              correlation: faker.random.word(),
              device: faker.random.word(),
              'egress-port': faker.random.word(),
              hostname: faker.random.word(),
              'ip-address': faker.random.word(),
              'ip-protocol': faker.random.word(),
              percent: faker.random.word(),
              'source-port': faker.random.word(),
            },
            'network-flood': {
              duration: faker.random.word(),
              'ip-address': faker.random.word(),
              parallel: faker.datatype.number({ min: undefined, max: undefined }),
              port: faker.random.word(),
              rate: faker.random.word(),
            },
            'network-loss': {
              correlation: faker.random.word(),
              device: faker.random.word(),
              'egress-port': faker.random.word(),
              hostname: faker.random.word(),
              'ip-address': faker.random.word(),
              'ip-protocol': faker.random.word(),
              percent: faker.random.word(),
              'source-port': faker.random.word(),
            },
            'network-partition': {
              'accept-tcp-flags': faker.random.word(),
              device: faker.random.word(),
              direction: faker.random.word(),
              hostname: faker.random.word(),
              'ip-address': faker.random.word(),
              'ip-protocol': faker.random.word(),
            },
            process: {
              process: faker.random.word(),
              recoverCmd: faker.random.word(),
              signal: faker.datatype.number({ min: undefined, max: undefined }),
            },
            'redis-cacheLimit': {
              addr: faker.random.word(),
              cacheSize: faker.random.word(),
              password: faker.random.word(),
              percent: faker.random.word(),
            },
            'redis-expiration': {
              addr: faker.random.word(),
              expiration: faker.random.word(),
              key: faker.random.word(),
              option: faker.random.word(),
              password: faker.random.word(),
            },
            'redis-penetration': {
              addr: faker.random.word(),
              password: faker.random.word(),
              requestNum: faker.datatype.number({ min: undefined, max: undefined }),
            },
            'redis-restart': {
              addr: faker.random.word(),
              conf: faker.random.word(),
              flushConfig: faker.datatype.boolean(),
              password: faker.random.word(),
              redisPath: faker.datatype.boolean(),
            },
            'redis-stop': {
              addr: faker.random.word(),
              conf: faker.random.word(),
              flushConfig: faker.datatype.boolean(),
              password: faker.random.word(),
              redisPath: faker.datatype.boolean(),
            },
            remoteCluster: faker.random.word(),
            selector: {
              annotationSelectors: {
                clfo3x4aa004vq0di5kv7ausn: faker.random.word(),
              },
              fieldSelectors: {
                clfo3x4aa004wq0di9a7cdr86: faker.random.word(),
              },
              labelSelectors: {
                clfo3x4aa004xq0di13b3dfol: faker.random.word(),
              },
              namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              ),
              physicalMachines: {
                clfo3x4aa004yq0dif1t0bgvl: Array.from(
                  { length: faker.datatype.number({ min: 1, max: 10 }) },
                  (_, i) => i + 1
                ).map(() => faker.random.word()),
              },
            },
            'stress-cpu': {
              load: faker.datatype.number({ min: undefined, max: undefined }),
              options: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              ),
              workers: faker.datatype.number({ min: undefined, max: undefined }),
            },
            'stress-mem': {
              options: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              ),
              size: faker.random.word(),
            },
            user_defined: { attackCmd: faker.random.word(), recoverCmd: faker.random.word() },
            value: faker.random.word(),
            vm: { 'vm-name': faker.random.word() },
          },
          podChaos: {
            action: faker.random.word(),
            containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => faker.random.word()
            ),
            duration: faker.random.word(),
            gracePeriod: faker.datatype.number({ min: undefined, max: undefined }),
            mode: faker.random.word(),
            remoteCluster: faker.random.word(),
            selector: {
              annotationSelectors: {
                clfo3x4aa004zq0di8vfx4ie7: faker.random.word(),
              },
              fieldSelectors: {
                clfo3x4aa0050q0di2wyng02m: faker.random.word(),
              },
              labelSelectors: {
                clfo3x4aa0051q0difcvd4aa9: faker.random.word(),
              },
              namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              ),
              nodeSelectors: {
                clfo3x4aa0052q0di7vb09pd5: faker.random.word(),
              },
              nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              ),
              podPhaseSelectors: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1
              ).map(() => faker.random.word()),
              pods: {
                clfo3x4aa0053q0dicjawd30e: Array.from(
                  { length: faker.datatype.number({ min: 1, max: 10 }) },
                  (_, i) => i + 1
                ).map(() => faker.random.word()),
              },
            },
            value: faker.random.word(),
          },
          schedule: faker.random.word(),
          startingDeadlineSeconds: faker.datatype.number({ min: undefined, max: undefined }),
          stressChaos: {
            containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => faker.random.word()
            ),
            duration: faker.random.word(),
            mode: faker.random.word(),
            remoteCluster: faker.random.word(),
            selector: {
              annotationSelectors: {
                clfo3x4aa0054q0dies3icfw1: faker.random.word(),
              },
              fieldSelectors: {
                clfo3x4aa0055q0di4jll95fi: faker.random.word(),
              },
              labelSelectors: {
                clfo3x4aa0056q0dia5rd45lv: faker.random.word(),
              },
              namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              ),
              nodeSelectors: {
                clfo3x4aa0057q0dig1y0ajxt: faker.random.word(),
              },
              nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              ),
              podPhaseSelectors: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1
              ).map(() => faker.random.word()),
              pods: {
                clfo3x4ab0058q0didkwub7fd: Array.from(
                  { length: faker.datatype.number({ min: 1, max: 10 }) },
                  (_, i) => i + 1
                ).map(() => faker.random.word()),
              },
            },
            stressngStressors: faker.random.word(),
            stressors: {
              cpu: {
                load: faker.datatype.number({ min: undefined, max: undefined }),
                options: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                  faker.random.word()
                ),
                workers: faker.datatype.number({ min: undefined, max: undefined }),
              },
              memory: {
                oomScoreAdj: faker.datatype.number({ min: undefined, max: undefined }),
                options: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                  faker.random.word()
                ),
                size: faker.random.word(),
                workers: faker.datatype.number({ min: undefined, max: undefined }),
              },
            },
            value: faker.random.word(),
          },
          timeChaos: {
            clockIds: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word()
            ),
            containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => faker.random.word()
            ),
            duration: faker.random.word(),
            mode: faker.random.word(),
            remoteCluster: faker.random.word(),
            selector: {
              annotationSelectors: {
                clfo3x4ab0059q0di0wxn5wwr: faker.random.word(),
              },
              fieldSelectors: {
                clfo3x4ab005aq0didw61c6jn: faker.random.word(),
              },
              labelSelectors: {
                clfo3x4ab005bq0di50z6ben5: faker.random.word(),
              },
              namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              ),
              nodeSelectors: {
                clfo3x4ab005cq0diervxe4aq: faker.random.word(),
              },
              nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              ),
              podPhaseSelectors: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1
              ).map(() => faker.random.word()),
              pods: {
                clfo3x4ab005dq0di3l8b3fw5: Array.from(
                  { length: faker.datatype.number({ min: 1, max: 10 }) },
                  (_, i) => i + 1
                ).map(() => faker.random.word()),
              },
            },
            timeOffset: faker.random.word(),
            value: faker.random.word(),
          },
          type: faker.random.word(),
        },
        statusCheck: {
          duration: faker.random.word(),
          failureThreshold: faker.datatype.number({ min: undefined, max: undefined }),
          http: {
            body: faker.random.word(),
            criteria: { statusCode: faker.random.word() },
            headers: {
              clfo3x4ab005eq0di4petas8k: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1
              ).map(() => faker.random.word()),
            },
            method: faker.random.word(),
            url: faker.random.word(),
          },
          intervalSeconds: faker.datatype.number({ min: undefined, max: undefined }),
          mode: faker.random.word(),
          recordsHistoryLimit: faker.datatype.number({ min: undefined, max: undefined }),
          successThreshold: faker.datatype.number({ min: undefined, max: undefined }),
          timeoutSeconds: faker.datatype.number({ min: undefined, max: undefined }),
          type: faker.random.word(),
        },
        stressChaos: {
          containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word()
          ),
          duration: faker.random.word(),
          mode: faker.random.word(),
          remoteCluster: faker.random.word(),
          selector: {
            annotationSelectors: {
              clfo3x4ab005fq0digg3c249y: faker.random.word(),
            },
            fieldSelectors: {
              clfo3x4ab005gq0di6ft5f3oy: faker.random.word(),
            },
            labelSelectors: {
              clfo3x4ab005hq0diem6y9092: faker.random.word(),
            },
            namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word()
            ),
            nodeSelectors: {
              clfo3x4ab005iq0di21v4ec8v: faker.random.word(),
            },
            nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word()
            ),
            podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => faker.random.word()
            ),
            pods: {
              clfo3x4ab005jq0di5yn91ymt: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1
              ).map(() => faker.random.word()),
            },
          },
          stressngStressors: faker.random.word(),
          stressors: {
            cpu: {
              load: faker.datatype.number({ min: undefined, max: undefined }),
              options: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              ),
              workers: faker.datatype.number({ min: undefined, max: undefined }),
            },
            memory: {
              oomScoreAdj: faker.datatype.number({ min: undefined, max: undefined }),
              options: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              ),
              size: faker.random.word(),
              workers: faker.datatype.number({ min: undefined, max: undefined }),
            },
          },
          value: faker.random.word(),
        },
        task: {
          container: {
            args: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word()
            ),
            command: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word()
            ),
            env: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
              name: faker.random.word(),
              value: faker.random.word(),
              valueFrom: {
                configMapKeyRef: {
                  key: faker.random.word(),
                  name: faker.random.word(),
                  optional: faker.datatype.boolean(),
                },
                fieldRef: { apiVersion: faker.random.word(), fieldPath: faker.random.word() },
                resourceFieldRef: {
                  containerName: faker.random.word(),
                  divisor: { Format: faker.random.word() },
                  resource: faker.random.word(),
                },
                secretKeyRef: {
                  key: faker.random.word(),
                  name: faker.random.word(),
                  optional: faker.datatype.boolean(),
                },
              },
            })),
            envFrom: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
              configMapRef: { name: faker.random.word(), optional: faker.datatype.boolean() },
              prefix: faker.random.word(),
              secretRef: { name: faker.random.word(), optional: faker.datatype.boolean() },
            })),
            image: faker.random.word(),
            imagePullPolicy: faker.random.word(),
            lifecycle: {
              postStart: {
                exec: {
                  command: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                    faker.random.word()
                  ),
                },
                httpGet: {
                  host: faker.random.word(),
                  httpHeaders: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                    () => ({ name: faker.random.word(), value: faker.random.word() })
                  ),
                  path: faker.random.word(),
                  port: {
                    intVal: faker.datatype.number({ min: undefined, max: undefined }),
                    strVal: faker.random.word(),
                    type: faker.datatype.number({ min: undefined, max: undefined }),
                  },
                  scheme: faker.random.word(),
                },
                tcpSocket: {
                  host: faker.random.word(),
                  port: {
                    intVal: faker.datatype.number({ min: undefined, max: undefined }),
                    strVal: faker.random.word(),
                    type: faker.datatype.number({ min: undefined, max: undefined }),
                  },
                },
              },
              preStop: {
                exec: {
                  command: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                    faker.random.word()
                  ),
                },
                httpGet: {
                  host: faker.random.word(),
                  httpHeaders: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                    () => ({ name: faker.random.word(), value: faker.random.word() })
                  ),
                  path: faker.random.word(),
                  port: {
                    intVal: faker.datatype.number({ min: undefined, max: undefined }),
                    strVal: faker.random.word(),
                    type: faker.datatype.number({ min: undefined, max: undefined }),
                  },
                  scheme: faker.random.word(),
                },
                tcpSocket: {
                  host: faker.random.word(),
                  port: {
                    intVal: faker.datatype.number({ min: undefined, max: undefined }),
                    strVal: faker.random.word(),
                    type: faker.datatype.number({ min: undefined, max: undefined }),
                  },
                },
              },
            },
            livenessProbe: {
              exec: {
                command: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                  faker.random.word()
                ),
              },
              failureThreshold: faker.datatype.number({ min: undefined, max: undefined }),
              grpc: { port: faker.datatype.number({ min: undefined, max: undefined }), service: faker.random.word() },
              httpGet: {
                host: faker.random.word(),
                httpHeaders: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                  () => ({ name: faker.random.word(), value: faker.random.word() })
                ),
                path: faker.random.word(),
                port: {
                  intVal: faker.datatype.number({ min: undefined, max: undefined }),
                  strVal: faker.random.word(),
                  type: faker.datatype.number({ min: undefined, max: undefined }),
                },
                scheme: faker.random.word(),
              },
              initialDelaySeconds: faker.datatype.number({ min: undefined, max: undefined }),
              periodSeconds: faker.datatype.number({ min: undefined, max: undefined }),
              successThreshold: faker.datatype.number({ min: undefined, max: undefined }),
              tcpSocket: {
                host: faker.random.word(),
                port: {
                  intVal: faker.datatype.number({ min: undefined, max: undefined }),
                  strVal: faker.random.word(),
                  type: faker.datatype.number({ min: undefined, max: undefined }),
                },
              },
              terminationGracePeriodSeconds: faker.datatype.number({ min: undefined, max: undefined }),
              timeoutSeconds: faker.datatype.number({ min: undefined, max: undefined }),
            },
            name: faker.random.word(),
            ports: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
              containerPort: faker.datatype.number({ min: undefined, max: undefined }),
              hostIP: faker.random.word(),
              hostPort: faker.datatype.number({ min: undefined, max: undefined }),
              name: faker.random.word(),
              protocol: faker.random.word(),
            })),
            readinessProbe: {
              exec: {
                command: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                  faker.random.word()
                ),
              },
              failureThreshold: faker.datatype.number({ min: undefined, max: undefined }),
              grpc: { port: faker.datatype.number({ min: undefined, max: undefined }), service: faker.random.word() },
              httpGet: {
                host: faker.random.word(),
                httpHeaders: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                  () => ({ name: faker.random.word(), value: faker.random.word() })
                ),
                path: faker.random.word(),
                port: {
                  intVal: faker.datatype.number({ min: undefined, max: undefined }),
                  strVal: faker.random.word(),
                  type: faker.datatype.number({ min: undefined, max: undefined }),
                },
                scheme: faker.random.word(),
              },
              initialDelaySeconds: faker.datatype.number({ min: undefined, max: undefined }),
              periodSeconds: faker.datatype.number({ min: undefined, max: undefined }),
              successThreshold: faker.datatype.number({ min: undefined, max: undefined }),
              tcpSocket: {
                host: faker.random.word(),
                port: {
                  intVal: faker.datatype.number({ min: undefined, max: undefined }),
                  strVal: faker.random.word(),
                  type: faker.datatype.number({ min: undefined, max: undefined }),
                },
              },
              terminationGracePeriodSeconds: faker.datatype.number({ min: undefined, max: undefined }),
              timeoutSeconds: faker.datatype.number({ min: undefined, max: undefined }),
            },
            resources: {
              claims: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
                name: faker.random.word(),
              })),
              limits: {
                clfo3x4ad005kq0di57j0eo8r: { Format: faker.random.word() },
              },
              requests: {
                clfo3x4ad005lq0di3b308yul: { Format: faker.random.word() },
              },
            },
            securityContext: {
              allowPrivilegeEscalation: faker.datatype.boolean(),
              capabilities: {
                add: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                  faker.random.word()
                ),
                drop: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                  faker.random.word()
                ),
              },
              privileged: faker.datatype.boolean(),
              procMount: faker.random.word(),
              readOnlyRootFilesystem: faker.datatype.boolean(),
              runAsGroup: faker.datatype.number({ min: undefined, max: undefined }),
              runAsNonRoot: faker.datatype.boolean(),
              runAsUser: faker.datatype.number({ min: undefined, max: undefined }),
              seLinuxOptions: {
                level: faker.random.word(),
                role: faker.random.word(),
                type: faker.random.word(),
                user: faker.random.word(),
              },
              seccompProfile: { localhostProfile: faker.random.word(), type: faker.random.word() },
              windowsOptions: {
                gmsaCredentialSpec: faker.random.word(),
                gmsaCredentialSpecName: faker.random.word(),
                hostProcess: faker.datatype.boolean(),
                runAsUserName: faker.random.word(),
              },
            },
            startupProbe: {
              exec: {
                command: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                  faker.random.word()
                ),
              },
              failureThreshold: faker.datatype.number({ min: undefined, max: undefined }),
              grpc: { port: faker.datatype.number({ min: undefined, max: undefined }), service: faker.random.word() },
              httpGet: {
                host: faker.random.word(),
                httpHeaders: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                  () => ({ name: faker.random.word(), value: faker.random.word() })
                ),
                path: faker.random.word(),
                port: {
                  intVal: faker.datatype.number({ min: undefined, max: undefined }),
                  strVal: faker.random.word(),
                  type: faker.datatype.number({ min: undefined, max: undefined }),
                },
                scheme: faker.random.word(),
              },
              initialDelaySeconds: faker.datatype.number({ min: undefined, max: undefined }),
              periodSeconds: faker.datatype.number({ min: undefined, max: undefined }),
              successThreshold: faker.datatype.number({ min: undefined, max: undefined }),
              tcpSocket: {
                host: faker.random.word(),
                port: {
                  intVal: faker.datatype.number({ min: undefined, max: undefined }),
                  strVal: faker.random.word(),
                  type: faker.datatype.number({ min: undefined, max: undefined }),
                },
              },
              terminationGracePeriodSeconds: faker.datatype.number({ min: undefined, max: undefined }),
              timeoutSeconds: faker.datatype.number({ min: undefined, max: undefined }),
            },
            stdin: faker.datatype.boolean(),
            stdinOnce: faker.datatype.boolean(),
            terminationMessagePath: faker.random.word(),
            terminationMessagePolicy: faker.random.word(),
            tty: faker.datatype.boolean(),
            volumeDevices: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => ({ devicePath: faker.random.word(), name: faker.random.word() })
            ),
            volumeMounts: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => ({
                mountPath: faker.random.word(),
                mountPropagation: faker.random.word(),
                name: faker.random.word(),
                readOnly: faker.datatype.boolean(),
                subPath: faker.random.word(),
                subPathExpr: faker.random.word(),
              })
            ),
            workingDir: faker.random.word(),
          },
          volumes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
            awsElasticBlockStore: {
              fsType: faker.random.word(),
              partition: faker.datatype.number({ min: undefined, max: undefined }),
              readOnly: faker.datatype.boolean(),
              volumeID: faker.random.word(),
            },
            azureDisk: {
              cachingMode: faker.random.word(),
              diskName: faker.random.word(),
              diskURI: faker.random.word(),
              fsType: faker.random.word(),
              kind: faker.random.word(),
              readOnly: faker.datatype.boolean(),
            },
            azureFile: {
              readOnly: faker.datatype.boolean(),
              secretName: faker.random.word(),
              shareName: faker.random.word(),
            },
            cephfs: {
              monitors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              ),
              path: faker.random.word(),
              readOnly: faker.datatype.boolean(),
              secretFile: faker.random.word(),
              secretRef: { name: faker.random.word() },
              user: faker.random.word(),
            },
            cinder: {
              fsType: faker.random.word(),
              readOnly: faker.datatype.boolean(),
              secretRef: { name: faker.random.word() },
              volumeID: faker.random.word(),
            },
            configMap: {
              defaultMode: faker.datatype.number({ min: undefined, max: undefined }),
              items: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
                key: faker.random.word(),
                mode: faker.datatype.number({ min: undefined, max: undefined }),
                path: faker.random.word(),
              })),
              name: faker.random.word(),
              optional: faker.datatype.boolean(),
            },
            csi: {
              driver: faker.random.word(),
              fsType: faker.random.word(),
              nodePublishSecretRef: { name: faker.random.word() },
              readOnly: faker.datatype.boolean(),
              volumeAttributes: {
                clfo3x4ad005mq0diaapa9tuu: faker.random.word(),
              },
            },
            downwardAPI: {
              defaultMode: faker.datatype.number({ min: undefined, max: undefined }),
              items: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
                fieldRef: { apiVersion: faker.random.word(), fieldPath: faker.random.word() },
                mode: faker.datatype.number({ min: undefined, max: undefined }),
                path: faker.random.word(),
                resourceFieldRef: {
                  containerName: faker.random.word(),
                  divisor: { Format: faker.random.word() },
                  resource: faker.random.word(),
                },
              })),
            },
            emptyDir: { medium: faker.random.word(), sizeLimit: { Format: faker.random.word() } },
            ephemeral: {
              volumeClaimTemplate: {
                annotations: {
                  clfo3x4ae005nq0diem5n0i8f: faker.random.word(),
                },
                creationTimestamp: faker.random.word(),
                deletionGracePeriodSeconds: faker.datatype.number({ min: undefined, max: undefined }),
                deletionTimestamp: faker.random.word(),
                finalizers: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                  () => faker.random.word()
                ),
                generateName: faker.random.word(),
                generation: faker.datatype.number({ min: undefined, max: undefined }),
                labels: {
                  clfo3x4ae005oq0di472eg7t0: faker.random.word(),
                },
                managedFields: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                  () => ({
                    apiVersion: faker.random.word(),
                    fieldsType: faker.random.word(),
                    fieldsV1: {},
                    manager: faker.random.word(),
                    operation: faker.random.word(),
                    subresource: faker.random.word(),
                    time: faker.random.word(),
                  })
                ),
                name: faker.random.word(),
                namespace: faker.random.word(),
                ownerReferences: Array.from(
                  { length: faker.datatype.number({ min: 1, max: 10 }) },
                  (_, i) => i + 1
                ).map(() => ({
                  apiVersion: faker.random.word(),
                  blockOwnerDeletion: faker.datatype.boolean(),
                  controller: faker.datatype.boolean(),
                  kind: faker.random.word(),
                  name: faker.random.word(),
                  uid: faker.random.word(),
                })),
                resourceVersion: faker.random.word(),
                selfLink: faker.random.word(),
                uid: faker.random.word(),
              },
            },
            fc: {
              fsType: faker.random.word(),
              lun: faker.datatype.number({ min: undefined, max: undefined }),
              readOnly: faker.datatype.boolean(),
              targetWWNs: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              ),
              wwids: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              ),
            },
            flexVolume: {
              driver: faker.random.word(),
              fsType: faker.random.word(),
              options: {
                clfo3x4ae005pq0di38e3b0r5: faker.random.word(),
              },
              readOnly: faker.datatype.boolean(),
              secretRef: { name: faker.random.word() },
            },
            flocker: { datasetName: faker.random.word(), datasetUUID: faker.random.word() },
            gcePersistentDisk: {
              fsType: faker.random.word(),
              partition: faker.datatype.number({ min: undefined, max: undefined }),
              pdName: faker.random.word(),
              readOnly: faker.datatype.boolean(),
            },
            gitRepo: { directory: faker.random.word(), repository: faker.random.word(), revision: faker.random.word() },
            glusterfs: {
              endpoints: faker.random.word(),
              path: faker.random.word(),
              readOnly: faker.datatype.boolean(),
            },
            hostPath: { path: faker.random.word(), type: faker.random.word() },
            iscsi: {
              chapAuthDiscovery: faker.datatype.boolean(),
              chapAuthSession: faker.datatype.boolean(),
              fsType: faker.random.word(),
              initiatorName: faker.random.word(),
              iqn: faker.random.word(),
              iscsiInterface: faker.random.word(),
              lun: faker.datatype.number({ min: undefined, max: undefined }),
              portals: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              ),
              readOnly: faker.datatype.boolean(),
              secretRef: { name: faker.random.word() },
              targetPortal: faker.random.word(),
            },
            name: faker.random.word(),
            nfs: { path: faker.random.word(), readOnly: faker.datatype.boolean(), server: faker.random.word() },
            persistentVolumeClaim: { claimName: faker.random.word(), readOnly: faker.datatype.boolean() },
            photonPersistentDisk: { fsType: faker.random.word(), pdID: faker.random.word() },
            portworxVolume: {
              fsType: faker.random.word(),
              readOnly: faker.datatype.boolean(),
              volumeID: faker.random.word(),
            },
            projected: {
              defaultMode: faker.datatype.number({ min: undefined, max: undefined }),
              sources: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
                configMap: {
                  items: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                    () => ({
                      key: faker.random.word(),
                      mode: faker.datatype.number({ min: undefined, max: undefined }),
                      path: faker.random.word(),
                    })
                  ),
                  name: faker.random.word(),
                  optional: faker.datatype.boolean(),
                },
                downwardAPI: {
                  items: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                    () => ({
                      fieldRef: { apiVersion: faker.random.word(), fieldPath: faker.random.word() },
                      mode: faker.datatype.number({ min: undefined, max: undefined }),
                      path: faker.random.word(),
                      resourceFieldRef: {
                        containerName: faker.random.word(),
                        divisor: { Format: faker.random.word() },
                        resource: faker.random.word(),
                      },
                    })
                  ),
                },
                secret: {
                  items: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                    () => ({
                      key: faker.random.word(),
                      mode: faker.datatype.number({ min: undefined, max: undefined }),
                      path: faker.random.word(),
                    })
                  ),
                  name: faker.random.word(),
                  optional: faker.datatype.boolean(),
                },
                serviceAccountToken: {
                  audience: faker.random.word(),
                  expirationSeconds: faker.datatype.number({ min: undefined, max: undefined }),
                  path: faker.random.word(),
                },
              })),
            },
            quobyte: {
              group: faker.random.word(),
              readOnly: faker.datatype.boolean(),
              registry: faker.random.word(),
              tenant: faker.random.word(),
              user: faker.random.word(),
              volume: faker.random.word(),
            },
            rbd: {
              fsType: faker.random.word(),
              image: faker.random.word(),
              keyring: faker.random.word(),
              monitors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              ),
              pool: faker.random.word(),
              readOnly: faker.datatype.boolean(),
              secretRef: { name: faker.random.word() },
              user: faker.random.word(),
            },
            scaleIO: {
              fsType: faker.random.word(),
              gateway: faker.random.word(),
              protectionDomain: faker.random.word(),
              readOnly: faker.datatype.boolean(),
              secretRef: { name: faker.random.word() },
              sslEnabled: faker.datatype.boolean(),
              storageMode: faker.random.word(),
              storagePool: faker.random.word(),
              system: faker.random.word(),
              volumeName: faker.random.word(),
            },
            secret: {
              defaultMode: faker.datatype.number({ min: undefined, max: undefined }),
              items: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
                key: faker.random.word(),
                mode: faker.datatype.number({ min: undefined, max: undefined }),
                path: faker.random.word(),
              })),
              optional: faker.datatype.boolean(),
              secretName: faker.random.word(),
            },
            storageos: {
              fsType: faker.random.word(),
              readOnly: faker.datatype.boolean(),
              secretRef: { name: faker.random.word() },
              volumeName: faker.random.word(),
              volumeNamespace: faker.random.word(),
            },
            vsphereVolume: {
              fsType: faker.random.word(),
              storagePolicyID: faker.random.word(),
              storagePolicyName: faker.random.word(),
              volumePath: faker.random.word(),
            },
          })),
        },
        templateType: faker.random.word(),
        timeChaos: {
          clockIds: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word()
          ),
          containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word()
          ),
          duration: faker.random.word(),
          mode: faker.random.word(),
          remoteCluster: faker.random.word(),
          selector: {
            annotationSelectors: {
              clfo3x4ae005qq0di2vgmellz: faker.random.word(),
            },
            fieldSelectors: {
              clfo3x4ae005rq0di0mlxao91: faker.random.word(),
            },
            labelSelectors: {
              clfo3x4ae005sq0didxcig8jo: faker.random.word(),
            },
            namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word()
            ),
            nodeSelectors: {
              clfo3x4ae005tq0dieez5dfr1: faker.random.word(),
            },
            nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word()
            ),
            podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => faker.random.word()
            ),
            pods: {
              clfo3x4ae005uq0di7lm5bodk: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1
              ).map(() => faker.random.word()),
            },
          },
          timeOffset: faker.random.word(),
          value: faker.random.word(),
        },
      })),
    },
  },
  status: {
    active: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
      apiVersion: faker.random.word(),
      fieldPath: faker.random.word(),
      kind: faker.random.word(),
      name: faker.random.word(),
      namespace: faker.random.word(),
      resourceVersion: faker.random.word(),
      uid: faker.random.word(),
    })),
    time: faker.random.word(),
  },
  uid: faker.random.word(),
})

export const getDeleteSchedulesUidMock = () => ({ status: faker.random.word() })

export const getGetSchedulesUidMock = () => ({
  created_at: faker.random.word(),
  experiment_uids: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
    faker.random.word()
  ),
  kind: faker.random.word(),
  kube_object: {
    apiVersion: faker.random.word(),
    kind: faker.random.word(),
    metadata: {
      annotations: {
        clfo3x4ag005vq0di99ntgrml: faker.random.word(),
      },
      labels: {
        clfo3x4ag005wq0di5h66hpui: faker.random.word(),
      },
      name: faker.random.word(),
      namespace: faker.random.word(),
    },
    spec: {},
  },
  name: faker.random.word(),
  namespace: faker.random.word(),
  status: faker.random.word(),
  uid: faker.random.word(),
})

export const getPutSchedulesPauseUidMock = () => ({ status: faker.random.word() })

export const getPutSchedulesStartUidMock = () => ({ status: faker.random.word() })

export const getGetTemplatesStatuschecksMock = () =>
  Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
    created_at: faker.random.word(),
    description: faker.random.word(),
    name: faker.random.word(),
    namespace: faker.random.word(),
    uid: faker.random.word(),
  }))

export const getPostTemplatesStatuschecksMock = () => ({
  description: faker.random.word(),
  name: faker.random.word(),
  namespace: faker.random.word(),
  spec: {
    duration: faker.random.word(),
    failureThreshold: faker.datatype.number({ min: undefined, max: undefined }),
    http: {
      body: faker.random.word(),
      criteria: { statusCode: faker.random.word() },
      headers: {
        clfo3x4ai005xq0diheqj2dm1: Array.from(
          { length: faker.datatype.number({ min: 1, max: 10 }) },
          (_, i) => i + 1
        ).map(() => faker.random.word()),
      },
      method: faker.random.word(),
      url: faker.random.word(),
    },
    intervalSeconds: faker.datatype.number({ min: undefined, max: undefined }),
    mode: faker.random.word(),
    recordsHistoryLimit: faker.datatype.number({ min: undefined, max: undefined }),
    successThreshold: faker.datatype.number({ min: undefined, max: undefined }),
    timeoutSeconds: faker.datatype.number({ min: undefined, max: undefined }),
    type: faker.random.word(),
  },
})

export const getDeleteTemplatesStatuschecksStatuscheckMock = () => ({ status: faker.random.word() })

export const getGetTemplatesStatuschecksStatuscheckMock = () => ({
  created_at: faker.random.word(),
  description: faker.random.word(),
  name: faker.random.word(),
  namespace: faker.random.word(),
  spec: {
    duration: faker.random.word(),
    failureThreshold: faker.datatype.number({ min: undefined, max: undefined }),
    http: {
      body: faker.random.word(),
      criteria: { statusCode: faker.random.word() },
      headers: {
        clfo3x4ak005yq0di61u45bbk: Array.from(
          { length: faker.datatype.number({ min: 1, max: 10 }) },
          (_, i) => i + 1
        ).map(() => faker.random.word()),
      },
      method: faker.random.word(),
      url: faker.random.word(),
    },
    intervalSeconds: faker.datatype.number({ min: undefined, max: undefined }),
    mode: faker.random.word(),
    recordsHistoryLimit: faker.datatype.number({ min: undefined, max: undefined }),
    successThreshold: faker.datatype.number({ min: undefined, max: undefined }),
    timeoutSeconds: faker.datatype.number({ min: undefined, max: undefined }),
    type: faker.random.word(),
  },
  uid: faker.random.word(),
})

export const getPutTemplatesStatuschecksStatuscheckMock = () => ({
  description: faker.random.word(),
  name: faker.random.word(),
  namespace: faker.random.word(),
  spec: {
    duration: faker.random.word(),
    failureThreshold: faker.datatype.number({ min: undefined, max: undefined }),
    http: {
      body: faker.random.word(),
      criteria: { statusCode: faker.random.word() },
      headers: {
        clfo3x4ak005zq0dih58o7keu: Array.from(
          { length: faker.datatype.number({ min: 1, max: 10 }) },
          (_, i) => i + 1
        ).map(() => faker.random.word()),
      },
      method: faker.random.word(),
      url: faker.random.word(),
    },
    intervalSeconds: faker.datatype.number({ min: undefined, max: undefined }),
    mode: faker.random.word(),
    recordsHistoryLimit: faker.datatype.number({ min: undefined, max: undefined }),
    successThreshold: faker.datatype.number({ min: undefined, max: undefined }),
    timeoutSeconds: faker.datatype.number({ min: undefined, max: undefined }),
    type: faker.random.word(),
  },
})

export const getGetWorkflowsMock = () =>
  Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
    created_at: faker.random.word(),
    end_time: faker.random.word(),
    entry: faker.random.word(),
    finish_time: faker.random.word(),
    id: faker.datatype.number({ min: undefined, max: undefined }),
    name: faker.random.word(),
    namespace: faker.random.word(),
    status: faker.random.word(),
    uid: faker.random.word(),
  }))

export const getPostWorkflowsMock = () => ({
  created_at: faker.random.word(),
  end_time: faker.random.word(),
  entry: faker.random.word(),
  finish_time: faker.random.word(),
  id: faker.datatype.number({ min: undefined, max: undefined }),
  kube_object: {
    apiVersion: faker.random.word(),
    kind: faker.random.word(),
    metadata: {
      annotations: {
        clfo3x4al0060q0di3azxckvk: faker.random.word(),
      },
      labels: {
        clfo3x4al0061q0diarmuapus: faker.random.word(),
      },
      name: faker.random.word(),
      namespace: faker.random.word(),
    },
    spec: {},
  },
  name: faker.random.word(),
  namespace: faker.random.word(),
  status: faker.random.word(),
  topology: {
    nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
      conditional_branches: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
        () => ({ expression: faker.random.word(), name: faker.random.word(), template: faker.random.word() })
      ),
      name: faker.random.word(),
      parallel: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
        name: faker.random.word(),
        template: faker.random.word(),
      })),
      serial: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
        name: faker.random.word(),
        template: faker.random.word(),
      })),
      state: faker.random.word(),
      template: faker.random.word(),
      type: faker.random.word(),
      uid: faker.random.word(),
    })),
  },
  uid: faker.random.word(),
})

export const getDeleteWorkflowsUidMock = () => ({ status: faker.random.word() })

export const getGetWorkflowsUidMock = () => ({
  created_at: faker.random.word(),
  end_time: faker.random.word(),
  entry: faker.random.word(),
  finish_time: faker.random.word(),
  id: faker.datatype.number({ min: undefined, max: undefined }),
  kube_object: {
    apiVersion: faker.random.word(),
    kind: faker.random.word(),
    metadata: {
      annotations: {
        clfo3x4am0062q0dicqt5bn6z: faker.random.word(),
      },
      labels: {
        clfo3x4am0063q0diftu50h17: faker.random.word(),
      },
      name: faker.random.word(),
      namespace: faker.random.word(),
    },
    spec: {},
  },
  name: faker.random.word(),
  namespace: faker.random.word(),
  status: faker.random.word(),
  topology: {
    nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
      conditional_branches: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
        () => ({ expression: faker.random.word(), name: faker.random.word(), template: faker.random.word() })
      ),
      name: faker.random.word(),
      parallel: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
        name: faker.random.word(),
        template: faker.random.word(),
      })),
      serial: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
        name: faker.random.word(),
        template: faker.random.word(),
      })),
      state: faker.random.word(),
      template: faker.random.word(),
      type: faker.random.word(),
      uid: faker.random.word(),
    })),
  },
  uid: faker.random.word(),
})

export const getPutWorkflowsUidMock = () => ({
  created_at: faker.random.word(),
  end_time: faker.random.word(),
  entry: faker.random.word(),
  finish_time: faker.random.word(),
  id: faker.datatype.number({ min: undefined, max: undefined }),
  kube_object: {
    apiVersion: faker.random.word(),
    kind: faker.random.word(),
    metadata: {
      annotations: {
        clfo3x4an0064q0dihzcz3pbz: faker.random.word(),
      },
      labels: {
        clfo3x4an0065q0dicg1m5kun: faker.random.word(),
      },
      name: faker.random.word(),
      namespace: faker.random.word(),
    },
    spec: {},
  },
  name: faker.random.word(),
  namespace: faker.random.word(),
  status: faker.random.word(),
  topology: {
    nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
      conditional_branches: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
        () => ({ expression: faker.random.word(), name: faker.random.word(), template: faker.random.word() })
      ),
      name: faker.random.word(),
      parallel: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
        name: faker.random.word(),
        template: faker.random.word(),
      })),
      serial: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
        name: faker.random.word(),
        template: faker.random.word(),
      })),
      state: faker.random.word(),
      template: faker.random.word(),
      type: faker.random.word(),
      uid: faker.random.word(),
    })),
  },
  uid: faker.random.word(),
})

export const getPostWorkflowsParseTaskHttpMock = () => ({
  body: faker.random.word(),
  followLocation: faker.datatype.boolean(),
  header: {
    clfo3x4an0066q0di6hbqbuw3: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
      () => faker.random.word()
    ),
  },
  jsonContent: faker.datatype.boolean(),
  method: faker.random.word(),
  name: faker.random.word(),
  url: faker.random.word(),
})

export const getPostWorkflowsRenderTaskHttpMock = () => ({
  abortWithStatusCheck: faker.datatype.boolean(),
  awsChaos: {
    action: faker.random.word(),
    awsRegion: faker.random.word(),
    deviceName: faker.random.word(),
    duration: faker.random.word(),
    ec2Instance: faker.random.word(),
    endpoint: faker.random.word(),
    remoteCluster: faker.random.word(),
    secretName: faker.random.word(),
    volumeID: faker.random.word(),
  },
  azureChaos: {
    action: faker.random.word(),
    diskName: faker.random.word(),
    duration: faker.random.word(),
    lun: faker.datatype.number({ min: undefined, max: undefined }),
    remoteCluster: faker.random.word(),
    resourceGroupName: faker.random.word(),
    secretName: faker.random.word(),
    subscriptionID: faker.random.word(),
    vmName: faker.random.word(),
  },
  blockChaos: {
    action: faker.random.word(),
    containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
      faker.random.word()
    ),
    delay: { correlation: faker.random.word(), jitter: faker.random.word(), latency: faker.random.word() },
    duration: faker.random.word(),
    mode: faker.random.word(),
    remoteCluster: faker.random.word(),
    selector: {
      annotationSelectors: {
        clfo3x4ao0067q0did0g58mfu: faker.random.word(),
      },
      fieldSelectors: {
        clfo3x4ao0068q0di6fo44xos: faker.random.word(),
      },
      labelSelectors: {
        clfo3x4ao0069q0di3oqsddtc: faker.random.word(),
      },
      namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      nodeSelectors: {
        clfo3x4ao006aq0di02o76d4k: faker.random.word(),
      },
      nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      pods: {
        clfo3x4ao006bq0di9lxv8g3w: Array.from(
          { length: faker.datatype.number({ min: 1, max: 10 }) },
          (_, i) => i + 1
        ).map(() => faker.random.word()),
      },
    },
    value: faker.random.word(),
    volumeName: faker.random.word(),
  },
  children: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
    faker.random.word()
  ),
  conditionalBranches: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
    expression: faker.random.word(),
    target: faker.random.word(),
  })),
  deadline: faker.random.word(),
  dnsChaos: {
    action: faker.random.word(),
    containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
      faker.random.word()
    ),
    duration: faker.random.word(),
    mode: faker.random.word(),
    patterns: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
      faker.random.word()
    ),
    remoteCluster: faker.random.word(),
    selector: {
      annotationSelectors: {
        clfo3x4ao006cq0di0tzzhllx: faker.random.word(),
      },
      fieldSelectors: {
        clfo3x4ao006dq0difnxo5gm7: faker.random.word(),
      },
      labelSelectors: {
        clfo3x4ao006eq0di2r3vd9wg: faker.random.word(),
      },
      namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      nodeSelectors: {
        clfo3x4ao006fq0di58nzan4h: faker.random.word(),
      },
      nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      pods: {
        clfo3x4ao006gq0di326cglay: Array.from(
          { length: faker.datatype.number({ min: 1, max: 10 }) },
          (_, i) => i + 1
        ).map(() => faker.random.word()),
      },
    },
    value: faker.random.word(),
  },
  gcpChaos: {
    action: faker.random.word(),
    deviceNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
      faker.random.word()
    ),
    duration: faker.random.word(),
    instance: faker.random.word(),
    project: faker.random.word(),
    remoteCluster: faker.random.word(),
    secretName: faker.random.word(),
    zone: faker.random.word(),
  },
  httpChaos: {
    abort: faker.datatype.boolean(),
    code: faker.datatype.number({ min: undefined, max: undefined }),
    delay: faker.random.word(),
    duration: faker.random.word(),
    method: faker.random.word(),
    mode: faker.random.word(),
    patch: {
      body: { type: faker.random.word(), value: faker.random.word() },
      headers: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        )
      ),
      queries: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        )
      ),
    },
    path: faker.random.word(),
    port: faker.datatype.number({ min: undefined, max: undefined }),
    remoteCluster: faker.random.word(),
    replace: {
      body: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.datatype.number({ min: undefined, max: undefined })
      ),
      code: faker.datatype.number({ min: undefined, max: undefined }),
      headers: {
        clfo3x4ao006hq0dib7hi6aez: faker.random.word(),
      },
      method: faker.random.word(),
      path: faker.random.word(),
      queries: {
        clfo3x4ao006iq0di6cfvf9zt: faker.random.word(),
      },
    },
    request_headers: {
      clfo3x4ao006jq0dici2k32y0: faker.random.word(),
    },
    response_headers: {
      clfo3x4ao006kq0di4hp3hmgg: faker.random.word(),
    },
    selector: {
      annotationSelectors: {
        clfo3x4ao006lq0dibulocgu8: faker.random.word(),
      },
      fieldSelectors: {
        clfo3x4ao006mq0dicr7welt1: faker.random.word(),
      },
      labelSelectors: {
        clfo3x4ao006nq0di4irte8jh: faker.random.word(),
      },
      namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      nodeSelectors: {
        clfo3x4ao006oq0di8997g3ku: faker.random.word(),
      },
      nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      pods: {
        clfo3x4ao006pq0di4b1phfnp: Array.from(
          { length: faker.datatype.number({ min: 1, max: 10 }) },
          (_, i) => i + 1
        ).map(() => faker.random.word()),
      },
    },
    target: faker.random.word(),
    tls: {
      caName: faker.random.word(),
      certName: faker.random.word(),
      keyName: faker.random.word(),
      secretName: faker.random.word(),
      secretNamespace: faker.random.word(),
    },
    value: faker.random.word(),
  },
  ioChaos: {
    action: faker.random.word(),
    attr: {
      atime: {
        nsec: faker.datatype.number({ min: undefined, max: undefined }),
        sec: faker.datatype.number({ min: undefined, max: undefined }),
      },
      blocks: faker.datatype.number({ min: undefined, max: undefined }),
      ctime: {
        nsec: faker.datatype.number({ min: undefined, max: undefined }),
        sec: faker.datatype.number({ min: undefined, max: undefined }),
      },
      gid: faker.datatype.number({ min: undefined, max: undefined }),
      ino: faker.datatype.number({ min: undefined, max: undefined }),
      kind: faker.random.word(),
      mtime: {
        nsec: faker.datatype.number({ min: undefined, max: undefined }),
        sec: faker.datatype.number({ min: undefined, max: undefined }),
      },
      nlink: faker.datatype.number({ min: undefined, max: undefined }),
      perm: faker.datatype.number({ min: undefined, max: undefined }),
      rdev: faker.datatype.number({ min: undefined, max: undefined }),
      size: faker.datatype.number({ min: undefined, max: undefined }),
      uid: faker.datatype.number({ min: undefined, max: undefined }),
    },
    containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
      faker.random.word()
    ),
    delay: faker.random.word(),
    duration: faker.random.word(),
    errno: faker.datatype.number({ min: undefined, max: undefined }),
    methods: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
      faker.random.word()
    ),
    mistake: {
      filling: faker.random.word(),
      maxLength: faker.datatype.number({ min: undefined, max: undefined }),
      maxOccurrences: faker.datatype.number({ min: undefined, max: undefined }),
    },
    mode: faker.random.word(),
    path: faker.random.word(),
    percent: faker.datatype.number({ min: undefined, max: undefined }),
    remoteCluster: faker.random.word(),
    selector: {
      annotationSelectors: {
        clfo3x4ao006qq0dig0f2c8j5: faker.random.word(),
      },
      fieldSelectors: {
        clfo3x4ao006rq0diebtj7z86: faker.random.word(),
      },
      labelSelectors: {
        clfo3x4ao006sq0dihu2odgjm: faker.random.word(),
      },
      namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      nodeSelectors: {
        clfo3x4ao006tq0di9el53qib: faker.random.word(),
      },
      nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      pods: {
        clfo3x4ao006uq0di7mfifoea: Array.from(
          { length: faker.datatype.number({ min: 1, max: 10 }) },
          (_, i) => i + 1
        ).map(() => faker.random.word()),
      },
    },
    value: faker.random.word(),
    volumePath: faker.random.word(),
  },
  jvmChaos: {
    action: faker.random.word(),
    class: faker.random.word(),
    containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
      faker.random.word()
    ),
    cpuCount: faker.datatype.number({ min: undefined, max: undefined }),
    database: faker.random.word(),
    duration: faker.random.word(),
    exception: faker.random.word(),
    latency: faker.datatype.number({ min: undefined, max: undefined }),
    memType: faker.random.word(),
    method: faker.random.word(),
    mode: faker.random.word(),
    mysqlConnectorVersion: faker.random.word(),
    name: faker.random.word(),
    pid: faker.datatype.number({ min: undefined, max: undefined }),
    port: faker.datatype.number({ min: undefined, max: undefined }),
    remoteCluster: faker.random.word(),
    ruleData: faker.random.word(),
    selector: {
      annotationSelectors: {
        clfo3x4ap006vq0di40i17qkv: faker.random.word(),
      },
      fieldSelectors: {
        clfo3x4ap006wq0digedle93v: faker.random.word(),
      },
      labelSelectors: {
        clfo3x4ap006xq0di4hz56yub: faker.random.word(),
      },
      namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      nodeSelectors: {
        clfo3x4ap006yq0dib21ug1pg: faker.random.word(),
      },
      nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      pods: {
        clfo3x4ap006zq0difa6b55yd: Array.from(
          { length: faker.datatype.number({ min: 1, max: 10 }) },
          (_, i) => i + 1
        ).map(() => faker.random.word()),
      },
    },
    sqlType: faker.random.word(),
    table: faker.random.word(),
    value: faker.random.word(),
  },
  kernelChaos: {
    containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
      faker.random.word()
    ),
    duration: faker.random.word(),
    failKernRequest: {
      callchain: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
        funcname: faker.random.word(),
        parameters: faker.random.word(),
        predicate: faker.random.word(),
      })),
      failtype: faker.datatype.number({ min: undefined, max: undefined }),
      headers: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      probability: faker.datatype.number({ min: undefined, max: undefined }),
      times: faker.datatype.number({ min: undefined, max: undefined }),
    },
    mode: faker.random.word(),
    remoteCluster: faker.random.word(),
    selector: {
      annotationSelectors: {
        clfo3x4ap0070q0di9fil6uz1: faker.random.word(),
      },
      fieldSelectors: {
        clfo3x4ap0071q0di8wzxffiq: faker.random.word(),
      },
      labelSelectors: {
        clfo3x4ap0072q0dichry3oon: faker.random.word(),
      },
      namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      nodeSelectors: {
        clfo3x4ap0073q0di3gu64mz9: faker.random.word(),
      },
      nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      pods: {
        clfo3x4ap0074q0die8hs07gr: Array.from(
          { length: faker.datatype.number({ min: 1, max: 10 }) },
          (_, i) => i + 1
        ).map(() => faker.random.word()),
      },
    },
    value: faker.random.word(),
  },
  name: faker.random.word(),
  networkChaos: {
    action: faker.random.word(),
    bandwidth: {
      buffer: faker.datatype.number({ min: undefined, max: undefined }),
      limit: faker.datatype.number({ min: undefined, max: undefined }),
      minburst: faker.datatype.number({ min: undefined, max: undefined }),
      peakrate: faker.datatype.number({ min: undefined, max: undefined }),
      rate: faker.random.word(),
    },
    corrupt: { correlation: faker.random.word(), corrupt: faker.random.word() },
    delay: {
      correlation: faker.random.word(),
      jitter: faker.random.word(),
      latency: faker.random.word(),
      reorder: {
        correlation: faker.random.word(),
        gap: faker.datatype.number({ min: undefined, max: undefined }),
        reorder: faker.random.word(),
      },
    },
    device: faker.random.word(),
    direction: faker.random.word(),
    duplicate: { correlation: faker.random.word(), duplicate: faker.random.word() },
    duration: faker.random.word(),
    externalTargets: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
      faker.random.word()
    ),
    loss: { correlation: faker.random.word(), loss: faker.random.word() },
    mode: faker.random.word(),
    remoteCluster: faker.random.word(),
    selector: {
      annotationSelectors: {
        clfo3x4ap0075q0diecgx4a55: faker.random.word(),
      },
      fieldSelectors: {
        clfo3x4ap0076q0die4p52cx6: faker.random.word(),
      },
      labelSelectors: {
        clfo3x4ap0077q0dibsko2bdx: faker.random.word(),
      },
      namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      nodeSelectors: {
        clfo3x4ap0078q0di10eq6s6r: faker.random.word(),
      },
      nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      pods: {
        clfo3x4ap0079q0di7zrdbfz4: Array.from(
          { length: faker.datatype.number({ min: 1, max: 10 }) },
          (_, i) => i + 1
        ).map(() => faker.random.word()),
      },
    },
    target: {
      mode: faker.random.word(),
      selector: {
        annotationSelectors: {
          clfo3x4ap007aq0digok71hu8: faker.random.word(),
        },
        fieldSelectors: {
          clfo3x4ap007bq0diglbpg912: faker.random.word(),
        },
        labelSelectors: {
          clfo3x4ap007cq0di6khmhu4b: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        nodeSelectors: {
          clfo3x4ap007dq0difv3y8uob: faker.random.word(),
        },
        nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        pods: {
          clfo3x4ap007eq0dic6vv2hgz: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1
          ).map(() => faker.random.word()),
        },
      },
      value: faker.random.word(),
    },
    targetDevice: faker.random.word(),
    value: faker.random.word(),
  },
  physicalmachineChaos: {
    action: faker.random.word(),
    address: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
      faker.random.word()
    ),
    clock: {
      'clock-ids-slice': faker.random.word(),
      pid: faker.datatype.number({ min: undefined, max: undefined }),
      'time-offset': faker.random.word(),
    },
    'disk-fill': {
      'fill-by-fallocate': faker.datatype.boolean(),
      path: faker.random.word(),
      size: faker.random.word(),
    },
    'disk-read-payload': {
      path: faker.random.word(),
      'payload-process-num': faker.datatype.number({ min: undefined, max: undefined }),
      size: faker.random.word(),
    },
    'disk-write-payload': {
      path: faker.random.word(),
      'payload-process-num': faker.datatype.number({ min: undefined, max: undefined }),
      size: faker.random.word(),
    },
    duration: faker.random.word(),
    'file-append': {
      count: faker.datatype.number({ min: undefined, max: undefined }),
      data: faker.random.word(),
      'file-name': faker.random.word(),
    },
    'file-create': { 'dir-name': faker.random.word(), 'file-name': faker.random.word() },
    'file-delete': { 'dir-name': faker.random.word(), 'file-name': faker.random.word() },
    'file-modify': {
      'file-name': faker.random.word(),
      privilege: faker.datatype.number({ min: undefined, max: undefined }),
    },
    'file-rename': { 'dest-file': faker.random.word(), 'source-file': faker.random.word() },
    'file-replace': {
      'dest-string': faker.random.word(),
      'file-name': faker.random.word(),
      line: faker.datatype.number({ min: undefined, max: undefined }),
      'origin-string': faker.random.word(),
    },
    'http-abort': {
      code: faker.random.word(),
      method: faker.random.word(),
      path: faker.random.word(),
      port: faker.datatype.number({ min: undefined, max: undefined }),
      proxy_ports: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.datatype.number({ min: undefined, max: undefined })
      ),
      target: faker.random.word(),
    },
    'http-config': { file_path: faker.random.word() },
    'http-delay': {
      code: faker.random.word(),
      delay: faker.random.word(),
      method: faker.random.word(),
      path: faker.random.word(),
      port: faker.datatype.number({ min: undefined, max: undefined }),
      proxy_ports: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.datatype.number({ min: undefined, max: undefined })
      ),
      target: faker.random.word(),
    },
    'http-request': {
      count: faker.datatype.number({ min: undefined, max: undefined }),
      'enable-conn-pool': faker.datatype.boolean(),
      url: faker.random.word(),
    },
    'jvm-exception': {
      class: faker.random.word(),
      exception: faker.random.word(),
      method: faker.random.word(),
      pid: faker.datatype.number({ min: undefined, max: undefined }),
      port: faker.datatype.number({ min: undefined, max: undefined }),
    },
    'jvm-gc': {
      pid: faker.datatype.number({ min: undefined, max: undefined }),
      port: faker.datatype.number({ min: undefined, max: undefined }),
    },
    'jvm-latency': {
      class: faker.random.word(),
      latency: faker.datatype.number({ min: undefined, max: undefined }),
      method: faker.random.word(),
      pid: faker.datatype.number({ min: undefined, max: undefined }),
      port: faker.datatype.number({ min: undefined, max: undefined }),
    },
    'jvm-mysql': {
      database: faker.random.word(),
      exception: faker.random.word(),
      latency: faker.datatype.number({ min: undefined, max: undefined }),
      mysqlConnectorVersion: faker.random.word(),
      pid: faker.datatype.number({ min: undefined, max: undefined }),
      port: faker.datatype.number({ min: undefined, max: undefined }),
      sqlType: faker.random.word(),
      table: faker.random.word(),
    },
    'jvm-return': {
      class: faker.random.word(),
      method: faker.random.word(),
      pid: faker.datatype.number({ min: undefined, max: undefined }),
      port: faker.datatype.number({ min: undefined, max: undefined }),
      value: faker.random.word(),
    },
    'jvm-rule-data': {
      pid: faker.datatype.number({ min: undefined, max: undefined }),
      port: faker.datatype.number({ min: undefined, max: undefined }),
      'rule-data': faker.random.word(),
    },
    'jvm-stress': {
      'cpu-count': faker.datatype.number({ min: undefined, max: undefined }),
      'mem-type': faker.random.word(),
      pid: faker.datatype.number({ min: undefined, max: undefined }),
      port: faker.datatype.number({ min: undefined, max: undefined }),
    },
    'kafka-fill': {
      host: faker.random.word(),
      maxBytes: faker.datatype.number({ min: undefined, max: undefined }),
      messageSize: faker.datatype.number({ min: undefined, max: undefined }),
      password: faker.random.word(),
      port: faker.datatype.number({ min: undefined, max: undefined }),
      reloadCommand: faker.random.word(),
      topic: faker.random.word(),
      username: faker.random.word(),
    },
    'kafka-flood': {
      host: faker.random.word(),
      messageSize: faker.datatype.number({ min: undefined, max: undefined }),
      password: faker.random.word(),
      port: faker.datatype.number({ min: undefined, max: undefined }),
      threads: faker.datatype.number({ min: undefined, max: undefined }),
      topic: faker.random.word(),
      username: faker.random.word(),
    },
    'kafka-io': {
      configFile: faker.random.word(),
      nonReadable: faker.datatype.boolean(),
      nonWritable: faker.datatype.boolean(),
      topic: faker.random.word(),
    },
    mode: faker.random.word(),
    'network-bandwidth': {
      buffer: faker.datatype.number({ min: undefined, max: undefined }),
      device: faker.random.word(),
      hostname: faker.random.word(),
      'ip-address': faker.random.word(),
      limit: faker.datatype.number({ min: undefined, max: undefined }),
      minburst: faker.datatype.number({ min: undefined, max: undefined }),
      peakrate: faker.datatype.number({ min: undefined, max: undefined }),
      rate: faker.random.word(),
    },
    'network-corrupt': {
      correlation: faker.random.word(),
      device: faker.random.word(),
      'egress-port': faker.random.word(),
      hostname: faker.random.word(),
      'ip-address': faker.random.word(),
      'ip-protocol': faker.random.word(),
      percent: faker.random.word(),
      'source-port': faker.random.word(),
    },
    'network-delay': {
      'accept-tcp-flags': faker.random.word(),
      correlation: faker.random.word(),
      device: faker.random.word(),
      'egress-port': faker.random.word(),
      hostname: faker.random.word(),
      'ip-address': faker.random.word(),
      'ip-protocol': faker.random.word(),
      jitter: faker.random.word(),
      latency: faker.random.word(),
      'source-port': faker.random.word(),
    },
    'network-dns': {
      'dns-domain-name': faker.random.word(),
      'dns-ip': faker.random.word(),
      'dns-server': faker.random.word(),
    },
    'network-down': { device: faker.random.word(), duration: faker.random.word() },
    'network-duplicate': {
      correlation: faker.random.word(),
      device: faker.random.word(),
      'egress-port': faker.random.word(),
      hostname: faker.random.word(),
      'ip-address': faker.random.word(),
      'ip-protocol': faker.random.word(),
      percent: faker.random.word(),
      'source-port': faker.random.word(),
    },
    'network-flood': {
      duration: faker.random.word(),
      'ip-address': faker.random.word(),
      parallel: faker.datatype.number({ min: undefined, max: undefined }),
      port: faker.random.word(),
      rate: faker.random.word(),
    },
    'network-loss': {
      correlation: faker.random.word(),
      device: faker.random.word(),
      'egress-port': faker.random.word(),
      hostname: faker.random.word(),
      'ip-address': faker.random.word(),
      'ip-protocol': faker.random.word(),
      percent: faker.random.word(),
      'source-port': faker.random.word(),
    },
    'network-partition': {
      'accept-tcp-flags': faker.random.word(),
      device: faker.random.word(),
      direction: faker.random.word(),
      hostname: faker.random.word(),
      'ip-address': faker.random.word(),
      'ip-protocol': faker.random.word(),
    },
    process: {
      process: faker.random.word(),
      recoverCmd: faker.random.word(),
      signal: faker.datatype.number({ min: undefined, max: undefined }),
    },
    'redis-cacheLimit': {
      addr: faker.random.word(),
      cacheSize: faker.random.word(),
      password: faker.random.word(),
      percent: faker.random.word(),
    },
    'redis-expiration': {
      addr: faker.random.word(),
      expiration: faker.random.word(),
      key: faker.random.word(),
      option: faker.random.word(),
      password: faker.random.word(),
    },
    'redis-penetration': {
      addr: faker.random.word(),
      password: faker.random.word(),
      requestNum: faker.datatype.number({ min: undefined, max: undefined }),
    },
    'redis-restart': {
      addr: faker.random.word(),
      conf: faker.random.word(),
      flushConfig: faker.datatype.boolean(),
      password: faker.random.word(),
      redisPath: faker.datatype.boolean(),
    },
    'redis-stop': {
      addr: faker.random.word(),
      conf: faker.random.word(),
      flushConfig: faker.datatype.boolean(),
      password: faker.random.word(),
      redisPath: faker.datatype.boolean(),
    },
    remoteCluster: faker.random.word(),
    selector: {
      annotationSelectors: {
        clfo3x4aq007fq0di1d5i6j17: faker.random.word(),
      },
      fieldSelectors: {
        clfo3x4aq007gq0di6uwi681c: faker.random.word(),
      },
      labelSelectors: {
        clfo3x4aq007hq0di9qiiaqlj: faker.random.word(),
      },
      namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      physicalMachines: {
        clfo3x4aq007iq0di1ykm069w: Array.from(
          { length: faker.datatype.number({ min: 1, max: 10 }) },
          (_, i) => i + 1
        ).map(() => faker.random.word()),
      },
    },
    'stress-cpu': {
      load: faker.datatype.number({ min: undefined, max: undefined }),
      options: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      workers: faker.datatype.number({ min: undefined, max: undefined }),
    },
    'stress-mem': {
      options: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      size: faker.random.word(),
    },
    user_defined: { attackCmd: faker.random.word(), recoverCmd: faker.random.word() },
    value: faker.random.word(),
    vm: { 'vm-name': faker.random.word() },
  },
  podChaos: {
    action: faker.random.word(),
    containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
      faker.random.word()
    ),
    duration: faker.random.word(),
    gracePeriod: faker.datatype.number({ min: undefined, max: undefined }),
    mode: faker.random.word(),
    remoteCluster: faker.random.word(),
    selector: {
      annotationSelectors: {
        clfo3x4aq007jq0di8sj2fhuu: faker.random.word(),
      },
      fieldSelectors: {
        clfo3x4aq007kq0di1gy2ede4: faker.random.word(),
      },
      labelSelectors: {
        clfo3x4aq007lq0di0pilgfyt: faker.random.word(),
      },
      namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      nodeSelectors: {
        clfo3x4aq007mq0dicei13gz6: faker.random.word(),
      },
      nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      pods: {
        clfo3x4aq007nq0di5v1t5pcb: Array.from(
          { length: faker.datatype.number({ min: 1, max: 10 }) },
          (_, i) => i + 1
        ).map(() => faker.random.word()),
      },
    },
    value: faker.random.word(),
  },
  schedule: {
    awsChaos: {
      action: faker.random.word(),
      awsRegion: faker.random.word(),
      deviceName: faker.random.word(),
      duration: faker.random.word(),
      ec2Instance: faker.random.word(),
      endpoint: faker.random.word(),
      remoteCluster: faker.random.word(),
      secretName: faker.random.word(),
      volumeID: faker.random.word(),
    },
    azureChaos: {
      action: faker.random.word(),
      diskName: faker.random.word(),
      duration: faker.random.word(),
      lun: faker.datatype.number({ min: undefined, max: undefined }),
      remoteCluster: faker.random.word(),
      resourceGroupName: faker.random.word(),
      secretName: faker.random.word(),
      subscriptionID: faker.random.word(),
      vmName: faker.random.word(),
    },
    blockChaos: {
      action: faker.random.word(),
      containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      delay: { correlation: faker.random.word(), jitter: faker.random.word(), latency: faker.random.word() },
      duration: faker.random.word(),
      mode: faker.random.word(),
      remoteCluster: faker.random.word(),
      selector: {
        annotationSelectors: {
          clfo3x4aq007oq0die6xkf69n: faker.random.word(),
        },
        fieldSelectors: {
          clfo3x4aq007pq0diemwf6rrf: faker.random.word(),
        },
        labelSelectors: {
          clfo3x4aq007qq0di0mdyby9p: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        nodeSelectors: {
          clfo3x4aq007rq0di2blj0t3g: faker.random.word(),
        },
        nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        pods: {
          clfo3x4aq007sq0di976r9ryr: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1
          ).map(() => faker.random.word()),
        },
      },
      value: faker.random.word(),
      volumeName: faker.random.word(),
    },
    concurrencyPolicy: faker.random.word(),
    dnsChaos: {
      action: faker.random.word(),
      containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      duration: faker.random.word(),
      mode: faker.random.word(),
      patterns: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      remoteCluster: faker.random.word(),
      selector: {
        annotationSelectors: {
          clfo3x4aq007tq0dibprg7db1: faker.random.word(),
        },
        fieldSelectors: {
          clfo3x4aq007uq0di6uni19z2: faker.random.word(),
        },
        labelSelectors: {
          clfo3x4aq007vq0di6cou3z0o: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        nodeSelectors: {
          clfo3x4aq007wq0di8rpf1ne2: faker.random.word(),
        },
        nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        pods: {
          clfo3x4aq007xq0di9um63uv6: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1
          ).map(() => faker.random.word()),
        },
      },
      value: faker.random.word(),
    },
    gcpChaos: {
      action: faker.random.word(),
      deviceNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      duration: faker.random.word(),
      instance: faker.random.word(),
      project: faker.random.word(),
      remoteCluster: faker.random.word(),
      secretName: faker.random.word(),
      zone: faker.random.word(),
    },
    historyLimit: faker.datatype.number({ min: undefined, max: undefined }),
    httpChaos: {
      abort: faker.datatype.boolean(),
      code: faker.datatype.number({ min: undefined, max: undefined }),
      delay: faker.random.word(),
      duration: faker.random.word(),
      method: faker.random.word(),
      mode: faker.random.word(),
      patch: {
        body: { type: faker.random.word(), value: faker.random.word() },
        headers: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word()
          )
        ),
        queries: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word()
          )
        ),
      },
      path: faker.random.word(),
      port: faker.datatype.number({ min: undefined, max: undefined }),
      remoteCluster: faker.random.word(),
      replace: {
        body: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.datatype.number({ min: undefined, max: undefined })
        ),
        code: faker.datatype.number({ min: undefined, max: undefined }),
        headers: {
          clfo3x4aq007yq0didyvdeqqp: faker.random.word(),
        },
        method: faker.random.word(),
        path: faker.random.word(),
        queries: {
          clfo3x4aq007zq0dicnz5g95k: faker.random.word(),
        },
      },
      request_headers: {
        clfo3x4aq0080q0di83go24r2: faker.random.word(),
      },
      response_headers: {
        clfo3x4aq0081q0di2cvz6kqw: faker.random.word(),
      },
      selector: {
        annotationSelectors: {
          clfo3x4aq0082q0dice271tgu: faker.random.word(),
        },
        fieldSelectors: {
          clfo3x4aq0083q0di9hkhacw6: faker.random.word(),
        },
        labelSelectors: {
          clfo3x4aq0084q0di9t6q3dwf: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        nodeSelectors: {
          clfo3x4aq0085q0difps8gu5y: faker.random.word(),
        },
        nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        pods: {
          clfo3x4aq0086q0di6ekrfw1o: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1
          ).map(() => faker.random.word()),
        },
      },
      target: faker.random.word(),
      tls: {
        caName: faker.random.word(),
        certName: faker.random.word(),
        keyName: faker.random.word(),
        secretName: faker.random.word(),
        secretNamespace: faker.random.word(),
      },
      value: faker.random.word(),
    },
    ioChaos: {
      action: faker.random.word(),
      attr: {
        atime: {
          nsec: faker.datatype.number({ min: undefined, max: undefined }),
          sec: faker.datatype.number({ min: undefined, max: undefined }),
        },
        blocks: faker.datatype.number({ min: undefined, max: undefined }),
        ctime: {
          nsec: faker.datatype.number({ min: undefined, max: undefined }),
          sec: faker.datatype.number({ min: undefined, max: undefined }),
        },
        gid: faker.datatype.number({ min: undefined, max: undefined }),
        ino: faker.datatype.number({ min: undefined, max: undefined }),
        kind: faker.random.word(),
        mtime: {
          nsec: faker.datatype.number({ min: undefined, max: undefined }),
          sec: faker.datatype.number({ min: undefined, max: undefined }),
        },
        nlink: faker.datatype.number({ min: undefined, max: undefined }),
        perm: faker.datatype.number({ min: undefined, max: undefined }),
        rdev: faker.datatype.number({ min: undefined, max: undefined }),
        size: faker.datatype.number({ min: undefined, max: undefined }),
        uid: faker.datatype.number({ min: undefined, max: undefined }),
      },
      containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      delay: faker.random.word(),
      duration: faker.random.word(),
      errno: faker.datatype.number({ min: undefined, max: undefined }),
      methods: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      mistake: {
        filling: faker.random.word(),
        maxLength: faker.datatype.number({ min: undefined, max: undefined }),
        maxOccurrences: faker.datatype.number({ min: undefined, max: undefined }),
      },
      mode: faker.random.word(),
      path: faker.random.word(),
      percent: faker.datatype.number({ min: undefined, max: undefined }),
      remoteCluster: faker.random.word(),
      selector: {
        annotationSelectors: {
          clfo3x4aq0087q0difyr7bjry: faker.random.word(),
        },
        fieldSelectors: {
          clfo3x4aq0088q0di0r2b1ra8: faker.random.word(),
        },
        labelSelectors: {
          clfo3x4aq0089q0dibmschjmo: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        nodeSelectors: {
          clfo3x4aq008aq0di6tvr5iy3: faker.random.word(),
        },
        nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        pods: {
          clfo3x4ar008bq0dia4x90wlp: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1
          ).map(() => faker.random.word()),
        },
      },
      value: faker.random.word(),
      volumePath: faker.random.word(),
    },
    jvmChaos: {
      action: faker.random.word(),
      class: faker.random.word(),
      containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      cpuCount: faker.datatype.number({ min: undefined, max: undefined }),
      database: faker.random.word(),
      duration: faker.random.word(),
      exception: faker.random.word(),
      latency: faker.datatype.number({ min: undefined, max: undefined }),
      memType: faker.random.word(),
      method: faker.random.word(),
      mode: faker.random.word(),
      mysqlConnectorVersion: faker.random.word(),
      name: faker.random.word(),
      pid: faker.datatype.number({ min: undefined, max: undefined }),
      port: faker.datatype.number({ min: undefined, max: undefined }),
      remoteCluster: faker.random.word(),
      ruleData: faker.random.word(),
      selector: {
        annotationSelectors: {
          clfo3x4ar008cq0digzgi001o: faker.random.word(),
        },
        fieldSelectors: {
          clfo3x4ar008dq0di0mmxh5at: faker.random.word(),
        },
        labelSelectors: {
          clfo3x4ar008eq0di5hrae3uf: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        nodeSelectors: {
          clfo3x4ar008fq0di7kno2of3: faker.random.word(),
        },
        nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        pods: {
          clfo3x4ar008gq0di14u0g0kv: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1
          ).map(() => faker.random.word()),
        },
      },
      sqlType: faker.random.word(),
      table: faker.random.word(),
      value: faker.random.word(),
    },
    kernelChaos: {
      containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      duration: faker.random.word(),
      failKernRequest: {
        callchain: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
          funcname: faker.random.word(),
          parameters: faker.random.word(),
          predicate: faker.random.word(),
        })),
        failtype: faker.datatype.number({ min: undefined, max: undefined }),
        headers: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        probability: faker.datatype.number({ min: undefined, max: undefined }),
        times: faker.datatype.number({ min: undefined, max: undefined }),
      },
      mode: faker.random.word(),
      remoteCluster: faker.random.word(),
      selector: {
        annotationSelectors: {
          clfo3x4ar008hq0di07gq1dz0: faker.random.word(),
        },
        fieldSelectors: {
          clfo3x4ar008iq0di3q201qkk: faker.random.word(),
        },
        labelSelectors: {
          clfo3x4ar008jq0di37tx2xxc: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        nodeSelectors: {
          clfo3x4ar008kq0dif7rz3oqb: faker.random.word(),
        },
        nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        pods: {
          clfo3x4ar008lq0didy6dhlu3: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1
          ).map(() => faker.random.word()),
        },
      },
      value: faker.random.word(),
    },
    networkChaos: {
      action: faker.random.word(),
      bandwidth: {
        buffer: faker.datatype.number({ min: undefined, max: undefined }),
        limit: faker.datatype.number({ min: undefined, max: undefined }),
        minburst: faker.datatype.number({ min: undefined, max: undefined }),
        peakrate: faker.datatype.number({ min: undefined, max: undefined }),
        rate: faker.random.word(),
      },
      corrupt: { correlation: faker.random.word(), corrupt: faker.random.word() },
      delay: {
        correlation: faker.random.word(),
        jitter: faker.random.word(),
        latency: faker.random.word(),
        reorder: {
          correlation: faker.random.word(),
          gap: faker.datatype.number({ min: undefined, max: undefined }),
          reorder: faker.random.word(),
        },
      },
      device: faker.random.word(),
      direction: faker.random.word(),
      duplicate: { correlation: faker.random.word(), duplicate: faker.random.word() },
      duration: faker.random.word(),
      externalTargets: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      loss: { correlation: faker.random.word(), loss: faker.random.word() },
      mode: faker.random.word(),
      remoteCluster: faker.random.word(),
      selector: {
        annotationSelectors: {
          clfo3x4ar008mq0di09d2agct: faker.random.word(),
        },
        fieldSelectors: {
          clfo3x4ar008nq0di205v21ra: faker.random.word(),
        },
        labelSelectors: {
          clfo3x4ar008oq0di8zonhgjt: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        nodeSelectors: {
          clfo3x4ar008pq0di1mmzgpuo: faker.random.word(),
        },
        nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        pods: {
          clfo3x4ar008qq0dib2zbhq1x: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1
          ).map(() => faker.random.word()),
        },
      },
      target: {
        mode: faker.random.word(),
        selector: {
          annotationSelectors: {
            clfo3x4ar008rq0die5jjc9n7: faker.random.word(),
          },
          fieldSelectors: {
            clfo3x4ar008sq0di9f637pfq: faker.random.word(),
          },
          labelSelectors: {
            clfo3x4ar008tq0di6tcb1psg: faker.random.word(),
          },
          namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word()
          ),
          nodeSelectors: {
            clfo3x4ar008uq0diaq790ecy: faker.random.word(),
          },
          nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word()
          ),
          podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
            () => faker.random.word()
          ),
          pods: {
            clfo3x4ar008vq0di8jood0j9: Array.from(
              { length: faker.datatype.number({ min: 1, max: 10 }) },
              (_, i) => i + 1
            ).map(() => faker.random.word()),
          },
        },
        value: faker.random.word(),
      },
      targetDevice: faker.random.word(),
      value: faker.random.word(),
    },
    physicalmachineChaos: {
      action: faker.random.word(),
      address: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      clock: {
        'clock-ids-slice': faker.random.word(),
        pid: faker.datatype.number({ min: undefined, max: undefined }),
        'time-offset': faker.random.word(),
      },
      'disk-fill': {
        'fill-by-fallocate': faker.datatype.boolean(),
        path: faker.random.word(),
        size: faker.random.word(),
      },
      'disk-read-payload': {
        path: faker.random.word(),
        'payload-process-num': faker.datatype.number({ min: undefined, max: undefined }),
        size: faker.random.word(),
      },
      'disk-write-payload': {
        path: faker.random.word(),
        'payload-process-num': faker.datatype.number({ min: undefined, max: undefined }),
        size: faker.random.word(),
      },
      duration: faker.random.word(),
      'file-append': {
        count: faker.datatype.number({ min: undefined, max: undefined }),
        data: faker.random.word(),
        'file-name': faker.random.word(),
      },
      'file-create': { 'dir-name': faker.random.word(), 'file-name': faker.random.word() },
      'file-delete': { 'dir-name': faker.random.word(), 'file-name': faker.random.word() },
      'file-modify': {
        'file-name': faker.random.word(),
        privilege: faker.datatype.number({ min: undefined, max: undefined }),
      },
      'file-rename': { 'dest-file': faker.random.word(), 'source-file': faker.random.word() },
      'file-replace': {
        'dest-string': faker.random.word(),
        'file-name': faker.random.word(),
        line: faker.datatype.number({ min: undefined, max: undefined }),
        'origin-string': faker.random.word(),
      },
      'http-abort': {
        code: faker.random.word(),
        method: faker.random.word(),
        path: faker.random.word(),
        port: faker.datatype.number({ min: undefined, max: undefined }),
        proxy_ports: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.datatype.number({ min: undefined, max: undefined })
        ),
        target: faker.random.word(),
      },
      'http-config': { file_path: faker.random.word() },
      'http-delay': {
        code: faker.random.word(),
        delay: faker.random.word(),
        method: faker.random.word(),
        path: faker.random.word(),
        port: faker.datatype.number({ min: undefined, max: undefined }),
        proxy_ports: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.datatype.number({ min: undefined, max: undefined })
        ),
        target: faker.random.word(),
      },
      'http-request': {
        count: faker.datatype.number({ min: undefined, max: undefined }),
        'enable-conn-pool': faker.datatype.boolean(),
        url: faker.random.word(),
      },
      'jvm-exception': {
        class: faker.random.word(),
        exception: faker.random.word(),
        method: faker.random.word(),
        pid: faker.datatype.number({ min: undefined, max: undefined }),
        port: faker.datatype.number({ min: undefined, max: undefined }),
      },
      'jvm-gc': {
        pid: faker.datatype.number({ min: undefined, max: undefined }),
        port: faker.datatype.number({ min: undefined, max: undefined }),
      },
      'jvm-latency': {
        class: faker.random.word(),
        latency: faker.datatype.number({ min: undefined, max: undefined }),
        method: faker.random.word(),
        pid: faker.datatype.number({ min: undefined, max: undefined }),
        port: faker.datatype.number({ min: undefined, max: undefined }),
      },
      'jvm-mysql': {
        database: faker.random.word(),
        exception: faker.random.word(),
        latency: faker.datatype.number({ min: undefined, max: undefined }),
        mysqlConnectorVersion: faker.random.word(),
        pid: faker.datatype.number({ min: undefined, max: undefined }),
        port: faker.datatype.number({ min: undefined, max: undefined }),
        sqlType: faker.random.word(),
        table: faker.random.word(),
      },
      'jvm-return': {
        class: faker.random.word(),
        method: faker.random.word(),
        pid: faker.datatype.number({ min: undefined, max: undefined }),
        port: faker.datatype.number({ min: undefined, max: undefined }),
        value: faker.random.word(),
      },
      'jvm-rule-data': {
        pid: faker.datatype.number({ min: undefined, max: undefined }),
        port: faker.datatype.number({ min: undefined, max: undefined }),
        'rule-data': faker.random.word(),
      },
      'jvm-stress': {
        'cpu-count': faker.datatype.number({ min: undefined, max: undefined }),
        'mem-type': faker.random.word(),
        pid: faker.datatype.number({ min: undefined, max: undefined }),
        port: faker.datatype.number({ min: undefined, max: undefined }),
      },
      'kafka-fill': {
        host: faker.random.word(),
        maxBytes: faker.datatype.number({ min: undefined, max: undefined }),
        messageSize: faker.datatype.number({ min: undefined, max: undefined }),
        password: faker.random.word(),
        port: faker.datatype.number({ min: undefined, max: undefined }),
        reloadCommand: faker.random.word(),
        topic: faker.random.word(),
        username: faker.random.word(),
      },
      'kafka-flood': {
        host: faker.random.word(),
        messageSize: faker.datatype.number({ min: undefined, max: undefined }),
        password: faker.random.word(),
        port: faker.datatype.number({ min: undefined, max: undefined }),
        threads: faker.datatype.number({ min: undefined, max: undefined }),
        topic: faker.random.word(),
        username: faker.random.word(),
      },
      'kafka-io': {
        configFile: faker.random.word(),
        nonReadable: faker.datatype.boolean(),
        nonWritable: faker.datatype.boolean(),
        topic: faker.random.word(),
      },
      mode: faker.random.word(),
      'network-bandwidth': {
        buffer: faker.datatype.number({ min: undefined, max: undefined }),
        device: faker.random.word(),
        hostname: faker.random.word(),
        'ip-address': faker.random.word(),
        limit: faker.datatype.number({ min: undefined, max: undefined }),
        minburst: faker.datatype.number({ min: undefined, max: undefined }),
        peakrate: faker.datatype.number({ min: undefined, max: undefined }),
        rate: faker.random.word(),
      },
      'network-corrupt': {
        correlation: faker.random.word(),
        device: faker.random.word(),
        'egress-port': faker.random.word(),
        hostname: faker.random.word(),
        'ip-address': faker.random.word(),
        'ip-protocol': faker.random.word(),
        percent: faker.random.word(),
        'source-port': faker.random.word(),
      },
      'network-delay': {
        'accept-tcp-flags': faker.random.word(),
        correlation: faker.random.word(),
        device: faker.random.word(),
        'egress-port': faker.random.word(),
        hostname: faker.random.word(),
        'ip-address': faker.random.word(),
        'ip-protocol': faker.random.word(),
        jitter: faker.random.word(),
        latency: faker.random.word(),
        'source-port': faker.random.word(),
      },
      'network-dns': {
        'dns-domain-name': faker.random.word(),
        'dns-ip': faker.random.word(),
        'dns-server': faker.random.word(),
      },
      'network-down': { device: faker.random.word(), duration: faker.random.word() },
      'network-duplicate': {
        correlation: faker.random.word(),
        device: faker.random.word(),
        'egress-port': faker.random.word(),
        hostname: faker.random.word(),
        'ip-address': faker.random.word(),
        'ip-protocol': faker.random.word(),
        percent: faker.random.word(),
        'source-port': faker.random.word(),
      },
      'network-flood': {
        duration: faker.random.word(),
        'ip-address': faker.random.word(),
        parallel: faker.datatype.number({ min: undefined, max: undefined }),
        port: faker.random.word(),
        rate: faker.random.word(),
      },
      'network-loss': {
        correlation: faker.random.word(),
        device: faker.random.word(),
        'egress-port': faker.random.word(),
        hostname: faker.random.word(),
        'ip-address': faker.random.word(),
        'ip-protocol': faker.random.word(),
        percent: faker.random.word(),
        'source-port': faker.random.word(),
      },
      'network-partition': {
        'accept-tcp-flags': faker.random.word(),
        device: faker.random.word(),
        direction: faker.random.word(),
        hostname: faker.random.word(),
        'ip-address': faker.random.word(),
        'ip-protocol': faker.random.word(),
      },
      process: {
        process: faker.random.word(),
        recoverCmd: faker.random.word(),
        signal: faker.datatype.number({ min: undefined, max: undefined }),
      },
      'redis-cacheLimit': {
        addr: faker.random.word(),
        cacheSize: faker.random.word(),
        password: faker.random.word(),
        percent: faker.random.word(),
      },
      'redis-expiration': {
        addr: faker.random.word(),
        expiration: faker.random.word(),
        key: faker.random.word(),
        option: faker.random.word(),
        password: faker.random.word(),
      },
      'redis-penetration': {
        addr: faker.random.word(),
        password: faker.random.word(),
        requestNum: faker.datatype.number({ min: undefined, max: undefined }),
      },
      'redis-restart': {
        addr: faker.random.word(),
        conf: faker.random.word(),
        flushConfig: faker.datatype.boolean(),
        password: faker.random.word(),
        redisPath: faker.datatype.boolean(),
      },
      'redis-stop': {
        addr: faker.random.word(),
        conf: faker.random.word(),
        flushConfig: faker.datatype.boolean(),
        password: faker.random.word(),
        redisPath: faker.datatype.boolean(),
      },
      remoteCluster: faker.random.word(),
      selector: {
        annotationSelectors: {
          clfo3x4as008wq0di78fh597k: faker.random.word(),
        },
        fieldSelectors: {
          clfo3x4as008xq0did1074hdl: faker.random.word(),
        },
        labelSelectors: {
          clfo3x4as008yq0digvxn7ban: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        physicalMachines: {
          clfo3x4as008zq0di5qgjacap: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1
          ).map(() => faker.random.word()),
        },
      },
      'stress-cpu': {
        load: faker.datatype.number({ min: undefined, max: undefined }),
        options: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        workers: faker.datatype.number({ min: undefined, max: undefined }),
      },
      'stress-mem': {
        options: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        size: faker.random.word(),
      },
      user_defined: { attackCmd: faker.random.word(), recoverCmd: faker.random.word() },
      value: faker.random.word(),
      vm: { 'vm-name': faker.random.word() },
    },
    podChaos: {
      action: faker.random.word(),
      containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      duration: faker.random.word(),
      gracePeriod: faker.datatype.number({ min: undefined, max: undefined }),
      mode: faker.random.word(),
      remoteCluster: faker.random.word(),
      selector: {
        annotationSelectors: {
          clfo3x4as0090q0di3qnb2qg5: faker.random.word(),
        },
        fieldSelectors: {
          clfo3x4as0091q0dif1spbjhz: faker.random.word(),
        },
        labelSelectors: {
          clfo3x4as0092q0di9exk13jg: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        nodeSelectors: {
          clfo3x4as0093q0dic7mm2rqq: faker.random.word(),
        },
        nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        pods: {
          clfo3x4as0094q0didy6n330g: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1
          ).map(() => faker.random.word()),
        },
      },
      value: faker.random.word(),
    },
    schedule: faker.random.word(),
    startingDeadlineSeconds: faker.datatype.number({ min: undefined, max: undefined }),
    stressChaos: {
      containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      duration: faker.random.word(),
      mode: faker.random.word(),
      remoteCluster: faker.random.word(),
      selector: {
        annotationSelectors: {
          clfo3x4as0095q0di3umi72vr: faker.random.word(),
        },
        fieldSelectors: {
          clfo3x4as0096q0di065i6om0: faker.random.word(),
        },
        labelSelectors: {
          clfo3x4as0097q0di1ctjcaht: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        nodeSelectors: {
          clfo3x4as0098q0di9orj6e21: faker.random.word(),
        },
        nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        pods: {
          clfo3x4as0099q0dienb8h592: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1
          ).map(() => faker.random.word()),
        },
      },
      stressngStressors: faker.random.word(),
      stressors: {
        cpu: {
          load: faker.datatype.number({ min: undefined, max: undefined }),
          options: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word()
          ),
          workers: faker.datatype.number({ min: undefined, max: undefined }),
        },
        memory: {
          oomScoreAdj: faker.datatype.number({ min: undefined, max: undefined }),
          options: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word()
          ),
          size: faker.random.word(),
          workers: faker.datatype.number({ min: undefined, max: undefined }),
        },
      },
      value: faker.random.word(),
    },
    timeChaos: {
      clockIds: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      duration: faker.random.word(),
      mode: faker.random.word(),
      remoteCluster: faker.random.word(),
      selector: {
        annotationSelectors: {
          clfo3x4as009aq0di4r392jny: faker.random.word(),
        },
        fieldSelectors: {
          clfo3x4as009bq0didatx16rg: faker.random.word(),
        },
        labelSelectors: {
          clfo3x4as009cq0didhqn699q: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        nodeSelectors: {
          clfo3x4as009dq0di4lix9tvb: faker.random.word(),
        },
        nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        pods: {
          clfo3x4as009eq0di7xmefn15: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1
          ).map(() => faker.random.word()),
        },
      },
      timeOffset: faker.random.word(),
      value: faker.random.word(),
    },
    type: faker.random.word(),
  },
  statusCheck: {
    duration: faker.random.word(),
    failureThreshold: faker.datatype.number({ min: undefined, max: undefined }),
    http: {
      body: faker.random.word(),
      criteria: { statusCode: faker.random.word() },
      headers: {
        clfo3x4as009fq0di6fiyawd0: Array.from(
          { length: faker.datatype.number({ min: 1, max: 10 }) },
          (_, i) => i + 1
        ).map(() => faker.random.word()),
      },
      method: faker.random.word(),
      url: faker.random.word(),
    },
    intervalSeconds: faker.datatype.number({ min: undefined, max: undefined }),
    mode: faker.random.word(),
    recordsHistoryLimit: faker.datatype.number({ min: undefined, max: undefined }),
    successThreshold: faker.datatype.number({ min: undefined, max: undefined }),
    timeoutSeconds: faker.datatype.number({ min: undefined, max: undefined }),
    type: faker.random.word(),
  },
  stressChaos: {
    containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
      faker.random.word()
    ),
    duration: faker.random.word(),
    mode: faker.random.word(),
    remoteCluster: faker.random.word(),
    selector: {
      annotationSelectors: {
        clfo3x4as009gq0diaq0z2kgy: faker.random.word(),
      },
      fieldSelectors: {
        clfo3x4as009hq0diabas2f49: faker.random.word(),
      },
      labelSelectors: {
        clfo3x4as009iq0diflbdhaqg: faker.random.word(),
      },
      namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      nodeSelectors: {
        clfo3x4as009jq0di6ilj0z4h: faker.random.word(),
      },
      nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      pods: {
        clfo3x4as009kq0di2yd524o1: Array.from(
          { length: faker.datatype.number({ min: 1, max: 10 }) },
          (_, i) => i + 1
        ).map(() => faker.random.word()),
      },
    },
    stressngStressors: faker.random.word(),
    stressors: {
      cpu: {
        load: faker.datatype.number({ min: undefined, max: undefined }),
        options: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        workers: faker.datatype.number({ min: undefined, max: undefined }),
      },
      memory: {
        oomScoreAdj: faker.datatype.number({ min: undefined, max: undefined }),
        options: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        size: faker.random.word(),
        workers: faker.datatype.number({ min: undefined, max: undefined }),
      },
    },
    value: faker.random.word(),
  },
  task: {
    container: {
      args: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      command: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      env: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
        name: faker.random.word(),
        value: faker.random.word(),
        valueFrom: {
          configMapKeyRef: { key: faker.random.word(), name: faker.random.word(), optional: faker.datatype.boolean() },
          fieldRef: { apiVersion: faker.random.word(), fieldPath: faker.random.word() },
          resourceFieldRef: {
            containerName: faker.random.word(),
            divisor: { Format: faker.random.word() },
            resource: faker.random.word(),
          },
          secretKeyRef: { key: faker.random.word(), name: faker.random.word(), optional: faker.datatype.boolean() },
        },
      })),
      envFrom: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
        configMapRef: { name: faker.random.word(), optional: faker.datatype.boolean() },
        prefix: faker.random.word(),
        secretRef: { name: faker.random.word(), optional: faker.datatype.boolean() },
      })),
      image: faker.random.word(),
      imagePullPolicy: faker.random.word(),
      lifecycle: {
        postStart: {
          exec: {
            command: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word()
            ),
          },
          httpGet: {
            host: faker.random.word(),
            httpHeaders: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => ({ name: faker.random.word(), value: faker.random.word() })
            ),
            path: faker.random.word(),
            port: {
              intVal: faker.datatype.number({ min: undefined, max: undefined }),
              strVal: faker.random.word(),
              type: faker.datatype.number({ min: undefined, max: undefined }),
            },
            scheme: faker.random.word(),
          },
          tcpSocket: {
            host: faker.random.word(),
            port: {
              intVal: faker.datatype.number({ min: undefined, max: undefined }),
              strVal: faker.random.word(),
              type: faker.datatype.number({ min: undefined, max: undefined }),
            },
          },
        },
        preStop: {
          exec: {
            command: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word()
            ),
          },
          httpGet: {
            host: faker.random.word(),
            httpHeaders: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => ({ name: faker.random.word(), value: faker.random.word() })
            ),
            path: faker.random.word(),
            port: {
              intVal: faker.datatype.number({ min: undefined, max: undefined }),
              strVal: faker.random.word(),
              type: faker.datatype.number({ min: undefined, max: undefined }),
            },
            scheme: faker.random.word(),
          },
          tcpSocket: {
            host: faker.random.word(),
            port: {
              intVal: faker.datatype.number({ min: undefined, max: undefined }),
              strVal: faker.random.word(),
              type: faker.datatype.number({ min: undefined, max: undefined }),
            },
          },
        },
      },
      livenessProbe: {
        exec: {
          command: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word()
          ),
        },
        failureThreshold: faker.datatype.number({ min: undefined, max: undefined }),
        grpc: { port: faker.datatype.number({ min: undefined, max: undefined }), service: faker.random.word() },
        httpGet: {
          host: faker.random.word(),
          httpHeaders: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
            name: faker.random.word(),
            value: faker.random.word(),
          })),
          path: faker.random.word(),
          port: {
            intVal: faker.datatype.number({ min: undefined, max: undefined }),
            strVal: faker.random.word(),
            type: faker.datatype.number({ min: undefined, max: undefined }),
          },
          scheme: faker.random.word(),
        },
        initialDelaySeconds: faker.datatype.number({ min: undefined, max: undefined }),
        periodSeconds: faker.datatype.number({ min: undefined, max: undefined }),
        successThreshold: faker.datatype.number({ min: undefined, max: undefined }),
        tcpSocket: {
          host: faker.random.word(),
          port: {
            intVal: faker.datatype.number({ min: undefined, max: undefined }),
            strVal: faker.random.word(),
            type: faker.datatype.number({ min: undefined, max: undefined }),
          },
        },
        terminationGracePeriodSeconds: faker.datatype.number({ min: undefined, max: undefined }),
        timeoutSeconds: faker.datatype.number({ min: undefined, max: undefined }),
      },
      name: faker.random.word(),
      ports: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
        containerPort: faker.datatype.number({ min: undefined, max: undefined }),
        hostIP: faker.random.word(),
        hostPort: faker.datatype.number({ min: undefined, max: undefined }),
        name: faker.random.word(),
        protocol: faker.random.word(),
      })),
      readinessProbe: {
        exec: {
          command: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word()
          ),
        },
        failureThreshold: faker.datatype.number({ min: undefined, max: undefined }),
        grpc: { port: faker.datatype.number({ min: undefined, max: undefined }), service: faker.random.word() },
        httpGet: {
          host: faker.random.word(),
          httpHeaders: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
            name: faker.random.word(),
            value: faker.random.word(),
          })),
          path: faker.random.word(),
          port: {
            intVal: faker.datatype.number({ min: undefined, max: undefined }),
            strVal: faker.random.word(),
            type: faker.datatype.number({ min: undefined, max: undefined }),
          },
          scheme: faker.random.word(),
        },
        initialDelaySeconds: faker.datatype.number({ min: undefined, max: undefined }),
        periodSeconds: faker.datatype.number({ min: undefined, max: undefined }),
        successThreshold: faker.datatype.number({ min: undefined, max: undefined }),
        tcpSocket: {
          host: faker.random.word(),
          port: {
            intVal: faker.datatype.number({ min: undefined, max: undefined }),
            strVal: faker.random.word(),
            type: faker.datatype.number({ min: undefined, max: undefined }),
          },
        },
        terminationGracePeriodSeconds: faker.datatype.number({ min: undefined, max: undefined }),
        timeoutSeconds: faker.datatype.number({ min: undefined, max: undefined }),
      },
      resources: {
        claims: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
          name: faker.random.word(),
        })),
        limits: {
          clfo3x4at009lq0di1o013bmo: { Format: faker.random.word() },
        },
        requests: {
          clfo3x4at009mq0di0nd23qqf: { Format: faker.random.word() },
        },
      },
      securityContext: {
        allowPrivilegeEscalation: faker.datatype.boolean(),
        capabilities: {
          add: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word()
          ),
          drop: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word()
          ),
        },
        privileged: faker.datatype.boolean(),
        procMount: faker.random.word(),
        readOnlyRootFilesystem: faker.datatype.boolean(),
        runAsGroup: faker.datatype.number({ min: undefined, max: undefined }),
        runAsNonRoot: faker.datatype.boolean(),
        runAsUser: faker.datatype.number({ min: undefined, max: undefined }),
        seLinuxOptions: {
          level: faker.random.word(),
          role: faker.random.word(),
          type: faker.random.word(),
          user: faker.random.word(),
        },
        seccompProfile: { localhostProfile: faker.random.word(), type: faker.random.word() },
        windowsOptions: {
          gmsaCredentialSpec: faker.random.word(),
          gmsaCredentialSpecName: faker.random.word(),
          hostProcess: faker.datatype.boolean(),
          runAsUserName: faker.random.word(),
        },
      },
      startupProbe: {
        exec: {
          command: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word()
          ),
        },
        failureThreshold: faker.datatype.number({ min: undefined, max: undefined }),
        grpc: { port: faker.datatype.number({ min: undefined, max: undefined }), service: faker.random.word() },
        httpGet: {
          host: faker.random.word(),
          httpHeaders: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
            name: faker.random.word(),
            value: faker.random.word(),
          })),
          path: faker.random.word(),
          port: {
            intVal: faker.datatype.number({ min: undefined, max: undefined }),
            strVal: faker.random.word(),
            type: faker.datatype.number({ min: undefined, max: undefined }),
          },
          scheme: faker.random.word(),
        },
        initialDelaySeconds: faker.datatype.number({ min: undefined, max: undefined }),
        periodSeconds: faker.datatype.number({ min: undefined, max: undefined }),
        successThreshold: faker.datatype.number({ min: undefined, max: undefined }),
        tcpSocket: {
          host: faker.random.word(),
          port: {
            intVal: faker.datatype.number({ min: undefined, max: undefined }),
            strVal: faker.random.word(),
            type: faker.datatype.number({ min: undefined, max: undefined }),
          },
        },
        terminationGracePeriodSeconds: faker.datatype.number({ min: undefined, max: undefined }),
        timeoutSeconds: faker.datatype.number({ min: undefined, max: undefined }),
      },
      stdin: faker.datatype.boolean(),
      stdinOnce: faker.datatype.boolean(),
      terminationMessagePath: faker.random.word(),
      terminationMessagePolicy: faker.random.word(),
      tty: faker.datatype.boolean(),
      volumeDevices: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
        devicePath: faker.random.word(),
        name: faker.random.word(),
      })),
      volumeMounts: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
        mountPath: faker.random.word(),
        mountPropagation: faker.random.word(),
        name: faker.random.word(),
        readOnly: faker.datatype.boolean(),
        subPath: faker.random.word(),
        subPathExpr: faker.random.word(),
      })),
      workingDir: faker.random.word(),
    },
    volumes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
      awsElasticBlockStore: {
        fsType: faker.random.word(),
        partition: faker.datatype.number({ min: undefined, max: undefined }),
        readOnly: faker.datatype.boolean(),
        volumeID: faker.random.word(),
      },
      azureDisk: {
        cachingMode: faker.random.word(),
        diskName: faker.random.word(),
        diskURI: faker.random.word(),
        fsType: faker.random.word(),
        kind: faker.random.word(),
        readOnly: faker.datatype.boolean(),
      },
      azureFile: {
        readOnly: faker.datatype.boolean(),
        secretName: faker.random.word(),
        shareName: faker.random.word(),
      },
      cephfs: {
        monitors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        path: faker.random.word(),
        readOnly: faker.datatype.boolean(),
        secretFile: faker.random.word(),
        secretRef: { name: faker.random.word() },
        user: faker.random.word(),
      },
      cinder: {
        fsType: faker.random.word(),
        readOnly: faker.datatype.boolean(),
        secretRef: { name: faker.random.word() },
        volumeID: faker.random.word(),
      },
      configMap: {
        defaultMode: faker.datatype.number({ min: undefined, max: undefined }),
        items: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
          key: faker.random.word(),
          mode: faker.datatype.number({ min: undefined, max: undefined }),
          path: faker.random.word(),
        })),
        name: faker.random.word(),
        optional: faker.datatype.boolean(),
      },
      csi: {
        driver: faker.random.word(),
        fsType: faker.random.word(),
        nodePublishSecretRef: { name: faker.random.word() },
        readOnly: faker.datatype.boolean(),
        volumeAttributes: {
          clfo3x4au009nq0di8xi8anfz: faker.random.word(),
        },
      },
      downwardAPI: {
        defaultMode: faker.datatype.number({ min: undefined, max: undefined }),
        items: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
          fieldRef: { apiVersion: faker.random.word(), fieldPath: faker.random.word() },
          mode: faker.datatype.number({ min: undefined, max: undefined }),
          path: faker.random.word(),
          resourceFieldRef: {
            containerName: faker.random.word(),
            divisor: { Format: faker.random.word() },
            resource: faker.random.word(),
          },
        })),
      },
      emptyDir: { medium: faker.random.word(), sizeLimit: { Format: faker.random.word() } },
      ephemeral: {
        volumeClaimTemplate: {
          annotations: {
            clfo3x4au009oq0dibb0j1qtc: faker.random.word(),
          },
          creationTimestamp: faker.random.word(),
          deletionGracePeriodSeconds: faker.datatype.number({ min: undefined, max: undefined }),
          deletionTimestamp: faker.random.word(),
          finalizers: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word()
          ),
          generateName: faker.random.word(),
          generation: faker.datatype.number({ min: undefined, max: undefined }),
          labels: {
            clfo3x4au009pq0dieokd3e04: faker.random.word(),
          },
          managedFields: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
            () => ({
              apiVersion: faker.random.word(),
              fieldsType: faker.random.word(),
              fieldsV1: {},
              manager: faker.random.word(),
              operation: faker.random.word(),
              subresource: faker.random.word(),
              time: faker.random.word(),
            })
          ),
          name: faker.random.word(),
          namespace: faker.random.word(),
          ownerReferences: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
            () => ({
              apiVersion: faker.random.word(),
              blockOwnerDeletion: faker.datatype.boolean(),
              controller: faker.datatype.boolean(),
              kind: faker.random.word(),
              name: faker.random.word(),
              uid: faker.random.word(),
            })
          ),
          resourceVersion: faker.random.word(),
          selfLink: faker.random.word(),
          spec: {
            accessModes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word()
            ),
            dataSource: { apiGroup: faker.random.word(), kind: faker.random.word(), name: faker.random.word() },
            dataSourceRef: {
              apiGroup: faker.random.word(),
              kind: faker.random.word(),
              name: faker.random.word(),
              namespace: faker.random.word(),
            },
            resources: {
              claims: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
                name: faker.random.word(),
              })),
              limits: {
                clfo3x4au009qq0die49fcwal: { Format: faker.random.word() },
              },
              requests: {
                clfo3x4au009rq0diab0f0j5e: { Format: faker.random.word() },
              },
            },
            selector: {
              matchExpressions: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                () => ({
                  key: faker.random.word(),
                  operator: faker.random.word(),
                  values: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                    faker.random.word()
                  ),
                })
              ),
              matchLabels: {
                clfo3x4au009sq0diax5gfu0d: faker.random.word(),
              },
            },
            storageClassName: faker.random.word(),
            volumeMode: faker.random.word(),
            volumeName: faker.random.word(),
          },
          uid: faker.random.word(),
        },
      },
      fc: {
        fsType: faker.random.word(),
        lun: faker.datatype.number({ min: undefined, max: undefined }),
        readOnly: faker.datatype.boolean(),
        targetWWNs: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        wwids: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
      },
      flexVolume: {
        driver: faker.random.word(),
        fsType: faker.random.word(),
        options: {
          clfo3x4au009tq0di2zjm7pqg: faker.random.word(),
        },
        readOnly: faker.datatype.boolean(),
        secretRef: { name: faker.random.word() },
      },
      flocker: { datasetName: faker.random.word(), datasetUUID: faker.random.word() },
      gcePersistentDisk: {
        fsType: faker.random.word(),
        partition: faker.datatype.number({ min: undefined, max: undefined }),
        pdName: faker.random.word(),
        readOnly: faker.datatype.boolean(),
      },
      gitRepo: { directory: faker.random.word(), repository: faker.random.word(), revision: faker.random.word() },
      glusterfs: { endpoints: faker.random.word(), path: faker.random.word(), readOnly: faker.datatype.boolean() },
      hostPath: { path: faker.random.word(), type: faker.random.word() },
      iscsi: {
        chapAuthDiscovery: faker.datatype.boolean(),
        chapAuthSession: faker.datatype.boolean(),
        fsType: faker.random.word(),
        initiatorName: faker.random.word(),
        iqn: faker.random.word(),
        iscsiInterface: faker.random.word(),
        lun: faker.datatype.number({ min: undefined, max: undefined }),
        portals: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        readOnly: faker.datatype.boolean(),
        secretRef: { name: faker.random.word() },
        targetPortal: faker.random.word(),
      },
      name: faker.random.word(),
      nfs: { path: faker.random.word(), readOnly: faker.datatype.boolean(), server: faker.random.word() },
      persistentVolumeClaim: { claimName: faker.random.word(), readOnly: faker.datatype.boolean() },
      photonPersistentDisk: { fsType: faker.random.word(), pdID: faker.random.word() },
      portworxVolume: {
        fsType: faker.random.word(),
        readOnly: faker.datatype.boolean(),
        volumeID: faker.random.word(),
      },
      projected: {
        defaultMode: faker.datatype.number({ min: undefined, max: undefined }),
        sources: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
          configMap: {
            items: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
              key: faker.random.word(),
              mode: faker.datatype.number({ min: undefined, max: undefined }),
              path: faker.random.word(),
            })),
            name: faker.random.word(),
            optional: faker.datatype.boolean(),
          },
          downwardAPI: {
            items: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
              fieldRef: { apiVersion: faker.random.word(), fieldPath: faker.random.word() },
              mode: faker.datatype.number({ min: undefined, max: undefined }),
              path: faker.random.word(),
              resourceFieldRef: {
                containerName: faker.random.word(),
                divisor: { Format: faker.random.word() },
                resource: faker.random.word(),
              },
            })),
          },
          secret: {
            items: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
              key: faker.random.word(),
              mode: faker.datatype.number({ min: undefined, max: undefined }),
              path: faker.random.word(),
            })),
            name: faker.random.word(),
            optional: faker.datatype.boolean(),
          },
          serviceAccountToken: {
            audience: faker.random.word(),
            expirationSeconds: faker.datatype.number({ min: undefined, max: undefined }),
            path: faker.random.word(),
          },
        })),
      },
      quobyte: {
        group: faker.random.word(),
        readOnly: faker.datatype.boolean(),
        registry: faker.random.word(),
        tenant: faker.random.word(),
        user: faker.random.word(),
        volume: faker.random.word(),
      },
      rbd: {
        fsType: faker.random.word(),
        image: faker.random.word(),
        keyring: faker.random.word(),
        monitors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        pool: faker.random.word(),
        readOnly: faker.datatype.boolean(),
        secretRef: { name: faker.random.word() },
        user: faker.random.word(),
      },
      scaleIO: {
        fsType: faker.random.word(),
        gateway: faker.random.word(),
        protectionDomain: faker.random.word(),
        readOnly: faker.datatype.boolean(),
        secretRef: { name: faker.random.word() },
        sslEnabled: faker.datatype.boolean(),
        storageMode: faker.random.word(),
        storagePool: faker.random.word(),
        system: faker.random.word(),
        volumeName: faker.random.word(),
      },
      secret: {
        defaultMode: faker.datatype.number({ min: undefined, max: undefined }),
        items: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
          key: faker.random.word(),
          mode: faker.datatype.number({ min: undefined, max: undefined }),
          path: faker.random.word(),
        })),
        optional: faker.datatype.boolean(),
        secretName: faker.random.word(),
      },
      storageos: {
        fsType: faker.random.word(),
        readOnly: faker.datatype.boolean(),
        secretRef: { name: faker.random.word() },
        volumeName: faker.random.word(),
        volumeNamespace: faker.random.word(),
      },
      vsphereVolume: {
        fsType: faker.random.word(),
        storagePolicyID: faker.random.word(),
        storagePolicyName: faker.random.word(),
        volumePath: faker.random.word(),
      },
    })),
  },
  templateType: faker.random.word(),
  timeChaos: {
    clockIds: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
      faker.random.word()
    ),
    containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
      faker.random.word()
    ),
    duration: faker.random.word(),
    mode: faker.random.word(),
    remoteCluster: faker.random.word(),
    selector: {
      annotationSelectors: {
        clfo3x4av009uq0dic8ml4rov: faker.random.word(),
      },
      fieldSelectors: {
        clfo3x4av009vq0di8cdqf0v0: faker.random.word(),
      },
      labelSelectors: {
        clfo3x4av009wq0die5an8qoh: faker.random.word(),
      },
      namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      nodeSelectors: {
        clfo3x4av009xq0dib55md0i2: faker.random.word(),
      },
      nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      pods: {
        clfo3x4av009yq0di0sqb2k1o: Array.from(
          { length: faker.datatype.number({ min: 1, max: 10 }) },
          (_, i) => i + 1
        ).map(() => faker.random.word()),
      },
    },
    timeOffset: faker.random.word(),
    value: faker.random.word(),
  },
})

export const getPostWorkflowsValidateTaskHttpMock = () => faker.datatype.boolean()

export const getChaosMeshDashboardAPIMSW = () => [
  rest.delete('*/archives', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getDeleteArchivesMock()))
  }),
  rest.get('*/archives', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetArchivesMock()))
  }),
  rest.delete('*/archives/:uid', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getDeleteArchivesUidMock()))
  }),
  rest.get('*/archives/:uid', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetArchivesUidMock()))
  }),
  rest.delete('*/archives/schedules', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getDeleteArchivesSchedulesMock()))
  }),
  rest.get('*/archives/schedules', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetArchivesSchedulesMock()))
  }),
  rest.delete('*/archives/schedules/:uid', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getDeleteArchivesSchedulesUidMock()))
  }),
  rest.get('*/archives/schedules/:uid', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetArchivesSchedulesUidMock()))
  }),
  rest.delete('*/archives/workflows', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getDeleteArchivesWorkflowsMock()))
  }),
  rest.get('*/archives/workflows', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetArchivesWorkflowsMock()))
  }),
  rest.delete('*/archives/workflows/:uid', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getDeleteArchivesWorkflowsUidMock()))
  }),
  rest.get('*/archives/workflows/:uid', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetArchivesWorkflowsUidMock()))
  }),
  rest.get('*/common/annotations', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetCommonAnnotationsMock()))
  }),
  rest.get('*/common/chaos-available-namespaces', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetCommonChaosAvailableNamespacesMock()))
  }),
  rest.get('*/common/config', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetCommonConfigMock()))
  }),
  rest.get('*/common/kinds', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetCommonKindsMock()))
  }),
  rest.get('*/common/labels', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetCommonLabelsMock()))
  }),
  rest.get('*/common/namespaces', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetCommonNamespacesMock()))
  }),
  rest.get('*/common/physicalmachine-annotations', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetCommonPhysicalmachineAnnotationsMock()))
  }),
  rest.get('*/common/physicalmachine-labels', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetCommonPhysicalmachineLabelsMock()))
  }),
  rest.post('*/common/physicalmachines', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getPostCommonPhysicalmachinesMock()))
  }),
  rest.post('*/common/pods', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getPostCommonPodsMock()))
  }),
  rest.get('*/common/rbac-config', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetCommonRbacConfigMock()))
  }),
  rest.get('*/events', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetEventsMock()))
  }),
  rest.get('*/events/:id', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetEventsIdMock()))
  }),
  rest.get('*/events/workflow/:uid', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetEventsWorkflowUidMock()))
  }),
  rest.delete('*/experiments', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getDeleteExperimentsMock()))
  }),
  rest.get('*/experiments', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetExperimentsMock()))
  }),
  rest.post('*/experiments', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getPostExperimentsMock()))
  }),
  rest.delete('*/experiments/:uid', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getDeleteExperimentsUidMock()))
  }),
  rest.get('*/experiments/:uid', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetExperimentsUidMock()))
  }),
  rest.put('*/experiments/pause/:uid', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getPutExperimentsPauseUidMock()))
  }),
  rest.put('*/experiments/start/:uid', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getPutExperimentsStartUidMock()))
  }),
  rest.get('*/experiments/state', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetExperimentsStateMock()))
  }),
  rest.delete('*/schedules', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getDeleteSchedulesMock()))
  }),
  rest.get('*/schedules', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetSchedulesMock()))
  }),
  rest.post('*/schedules', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getPostSchedulesMock()))
  }),
  rest.delete('*/schedules/:uid', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getDeleteSchedulesUidMock()))
  }),
  rest.get('*/schedules/:uid', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetSchedulesUidMock()))
  }),
  rest.put('*/schedules/pause/:uid', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getPutSchedulesPauseUidMock()))
  }),
  rest.put('*/schedules/start/:uid', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getPutSchedulesStartUidMock()))
  }),
  rest.get('*/templates/statuschecks', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetTemplatesStatuschecksMock()))
  }),
  rest.post('*/templates/statuschecks', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getPostTemplatesStatuschecksMock()))
  }),
  rest.delete('*/templates/statuschecks/statuscheck', (_req, res, ctx) => {
    return res(
      ctx.delay(0),
      ctx.status(200, 'Mocked status'),
      ctx.json(getDeleteTemplatesStatuschecksStatuscheckMock())
    )
  }),
  rest.get('*/templates/statuschecks/statuscheck', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetTemplatesStatuschecksStatuscheckMock()))
  }),
  rest.put('*/templates/statuschecks/statuscheck', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getPutTemplatesStatuschecksStatuscheckMock()))
  }),
  rest.get('*/workflows', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetWorkflowsMock()))
  }),
  rest.post('*/workflows', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getPostWorkflowsMock()))
  }),
  rest.delete('*/workflows/:uid', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getDeleteWorkflowsUidMock()))
  }),
  rest.get('*/workflows/:uid', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetWorkflowsUidMock()))
  }),
  rest.put('*/workflows/:uid', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getPutWorkflowsUidMock()))
  }),
  rest.post('*/workflows/parse-task/http', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getPostWorkflowsParseTaskHttpMock()))
  }),
  rest.post('*/workflows/render-task/http', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getPostWorkflowsRenderTaskHttpMock()))
  }),
  rest.post('*/workflows/validate-task/http', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getPostWorkflowsValidateTaskHttpMock()))
  }),
]
