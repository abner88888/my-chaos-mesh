import { getUIFormAction, getUIFormEnum, isUIFormIgnore } from './utils.js'

import fs from 'fs'
import { nodeToField } from './factory.js'
import sig from 'signale'
import ts from 'typescript'

const { factory } = ts

const WARNING_MESSAGE = `/**
 * This file was auto-generated by @ui/openapi.
 * Do not make direct changes to the file.
 */

`
const SHARED_KEYWORD = 'shared'
const ignores = ['selector', 'mode', 'value', 'duration']

/**
 * Generate forms needed data from schemas.
 *
 * @param {string} source
 */
export function genForms(source) {
  const chaos = [
    'AWSChaos',
    'DNSChaos',
    'GCPChaos',
    // 'HTTPChaos',
    'IOChaos',
    'JVMChaos',
    'KernelChaos',
    'NetworkChaos',
    // 'PhysicalMachineChaos',
    'PodChaos',
    'StressChaos',
    'TimeChaos',
  ]

  const program = ts.createProgram([source], {
    target: ts.ScriptTarget.ES2015,
  })
  const sourceFile = program.getSourceFile(source)
  const checker = program.getTypeChecker()
  const nodes = sourceFile.getChildAt(0).getChildren()
  // 1. filter all required schemas
  const interfaces = nodes.filter((node) => node.kind === ts.SyntaxKind.InterfaceDeclaration)

  chaos.forEach((child) => {
    let actions = []
    const propertyAssignments = []

    // 2. find the corresponding spec
    //
    // all specs will follow the format of `V1alpha1XXXChaosSpec`
    const spec = interfaces.find((node) => node.name.escapedText === `V1alpha1${child}Spec`)

    spec.members.forEach((node) => {
      switch (node.kind) {
        case ts.SyntaxKind.PropertySignature:
          /** @type {string} */
          const identifier = node.name.escapedText
          if (ignores.includes(identifier)) {
            break
          }

          /** @type {string} */
          const comment = node.jsDoc[0].comment ?? '' // prevent error when comment is undefined

          if (identifier === 'action') {
            // get all actions
            actions = getUIFormEnum(comment)
          } else {
            // ignore specifc fields
            if (isUIFormIgnore(comment)) {
              break
            }

            propertyAssignments.push({
              action: getUIFormAction(comment) || SHARED_KEYWORD,
              field: nodeToField(identifier, node.type, comment, [], sourceFile, checker),
            })
          }

          break
        default:
          break
      }
    })

    const actionFields = []
    actions.forEach((action) => {
      const paByAction = propertyAssignments.filter((p) => p.action === action).map((p) => p.field)
      const identifierShared = factory.createIdentifier(SHARED_KEYWORD)

      actionFields.push(
        factory.createPropertyAssignment(
          factory.createStringLiteral(action),
          paByAction.length
            ? factory.createArrayLiteralExpression([factory.createSpreadElement(identifierShared), ...paByAction], true)
            : identifierShared
        )
      )
    })

    const shared = factory.createVariableStatement(
      undefined,
      factory.createVariableDeclarationList(
        [
          factory.createVariableDeclaration(
            factory.createIdentifier(SHARED_KEYWORD),
            undefined,
            undefined,
            factory.createArrayLiteralExpression(
              propertyAssignments.filter((p) => p.action === SHARED_KEYWORD).map((p) => p.field),
              true
            )
          ),
        ],
        ts.NodeFlags.Const
      )
    )
    const exportDefault = factory.createExportDefault(
      actions.length
        ? factory.createObjectLiteralExpression(actionFields, true)
        : factory.createIdentifier(SHARED_KEYWORD)
    )

    const printer = ts.createPrinter({
      omitTrailingSemicolon: true,
    })
    /**
     * Encapsulate printNode method.
     *
     * @param {ts.Node} node
     * @return {string}
     */
    function printNode(node) {
      return printer.printNode(ts.EmitHint.Unspecified, node, sourceFile)
    }
    const sharedPrint = printNode(shared)
    const exportDefaultPrint = printNode(exportDefault)

    const file = `./formik/${child}.ts`
    fs.writeFile(file, WARNING_MESSAGE + sharedPrint + '\n\n' + exportDefaultPrint + '\n', (err) => {
      if (err) {
        sig.error(err)
      } else {
        sig.success(`${child} form data generated`)
      }
    })
  })
}
